repo_id,file_path,content
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\common\ExcludeFromCodeCoverageAttribute.cs,"using System.Diagnostics.CodeAnalysis;  [assembly: ExcludeFromCodeCoverage]  namespace System.Diagnostics.CodeAnalysis;  [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Event | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)] internal sealed class ExcludeFromCodeCoverageAttribute : Attribute { 	public ExcludeFromCodeCoverageAttribute() { } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\common.tests\Program.cs,"// This file is similar to the auto-generated entrypoint, except that we also add an // explicit reference to the TD.NET runner, since that would normally come in via // the NuGet package and a .tdnet file.  using TestDriven.Framework; using Xunit.Runner.InProc.SystemConsole;  [assembly: CustomTestRunner(typeof(Xunit.Runner.TdNet.TdNetRunner))]  public class AutoGeneratedEntryPoint { 	public static int Main(string[] args) => 		ConsoleRunner.Run(args).GetAwaiter().GetResult(); }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v2.tests\ResolveGenericMethodTests.cs,"using System; using System.Collections.Generic; using System.Linq; using Xunit; using Xunit.Abstractions; using Xunit.Sdk;  public class ResolveGenericMethodTests { 	public static IEnumerable<object[]> ResolveGenericType_TestData() 	{ 		// Method() 		yield return new object[] 		{ 			nameof(NoGenericParameters_NoParameters), 			new object[0], 			new Type[0] 		};  		// Method(int) 		yield return new object[] 		{ 			nameof(NoGenericParameters_OneParameter), 			new object[] { 1 }, 			new Type[0] 		};  		// Method<T>() 		yield return new object[] 		{ 			nameof(OneGenericParameter_NotUsed_NoParameters), 			new object[0], 			new Type[] { typeof(object) } 		};  		// Method<T>(T) non-null 		yield return new object[] 		{ 			nameof(OneGenericParameter_Used_OneParameter), 			new object[] { 1 }, 			new Type[] { typeof(int) } 		};  		// Method<T>(T) null 		yield return new object[] 		{ 			nameof(OneGenericParameter_Used_OneParameter), 			new object[] { null }, 			new Type[] { typeof(object) } 		};  		// Method<T>(T) array 		yield return new object[] 		{ 			nameof(OneGenericParameter_Used_OneParameter), 			new object[] { new int[5] }, 			new Type[] { typeof(int[]) } 		};  		// Method<T>(T, T) matching 		yield return new object[] 		{ 			nameof(OneGenericParameter_UsedTwice_TwoParameters), 			new object[] { 1, 2 }, 			new Type[] { typeof(int) } 		};  		// Method<T>(T, T) non matching 		yield return new object[] 		{ 			nameof(OneGenericParameter_UsedTwice_TwoParameters), 			new object[] { 1, ""2"" }, 			new Type[] { typeof(int) } 		};  		// Method<T>(T, int) 		yield return new object[] 		{ 			nameof(OneGenericParameter_UsedOnceFirst_TwoParameters), 			new object[] { ""1"", 2 }, 			new Type[] { typeof(string) } 		};  		// Method<T>(int, T) 		yield return new object[] 		{ 			nameof(OneGenericParameter_UsedOnceSecond_TwoParameters), 			new object[] { 1, ""2"" }, 			new Type[] { typeof(string) } 		};  		// Method<T>(int) 		yield return new object[] 		{ 			nameof(OneGenericParameter_NotUsed_OneParameter), 			new object[] { 1 }, 			new Type[] { typeof(object) } 		};  		// Method<T, U>() 		yield return new object[] 		{ 			nameof(TwoGenericParameters_NoneUsed_NoParameters), 			new object[0], 			new Type[] { typeof(object), typeof(object) } 		};  		// Method<T, U>(int) 		yield return new object[] 		{ 			nameof(TwoGenericParameters_NoneUsed_OneParameter), 			new object[] { 1 }, 			new Type[] { typeof(object), typeof(object) } 		};  		// Method<T, U>(int, long) 		yield return new object[] 		{ 			nameof(TwoGenericParameters_NoneUsed_TwoParameters), 			new object[] { 1, 2L }, 			new Type[] { typeof(object), typeof(object) } 		};  		// Method<T, U>(T) 		yield return new object[] 		{ 			nameof(TwoGenericParameters_OnlyFirstUsed_OneParameter), 			new object[] { 1 }, 			new Type[] { typeof(int), typeof(object) } 		};  		// Method<T, U>(U) 		yield return new object[] 		{ 			nameof(TwoGenericParameters_OnlySecondUsed_OneParameter), 			new object[] { 1 }, 			new Type[] { typeof(object), typeof(int) } 		};  		// Method<T, U>(T, T) matching 		yield return new object[] 		{ 			nameof(TwoGenericParameters_OnlyFirstUsed_TwoParameters), 			new object[] { 1, 2 }, 			new Type[] { typeof(int), typeof(object) } 		};  		// Method<T, U>(T, T) unmatching 		yield return new object[] 		{ 			nameof(TwoGenericParameters_OnlyFirstUsed_TwoParameters), 			new object[] { 1, ""2"" }, 			new Type[] { typeof(int), typeof(object) } 		};  		// Method<T, U>(U, U) matching 		yield return new object[] 		{ 			nameof(TwoGenericParameters_OnlySecondUsed_TwoParameters), 			new object[] { 1, 2 }, 			new Type[] { typeof(object), typeof(int) } 		};  		// Method<T, U>(U, U) unmatching 		yield return new object[] 		{ 			nameof(TwoGenericParameters_OnlySecondUsed_TwoParameters), 			new object[] { 1, ""2"" }, 			new Type[] { typeof(object), typeof(int) } 		};  		// Method<T, U>(T, U) with normal inputs 		yield return new object[] 		{ 			nameof(TwoGenericParameters_TwoUsed_TwoParameters), 			new object[] { 5, null }, 			new Type[] { typeof(int), typeof(object) } 		};  		// Method<T, U>(T, U) with array inputs 		yield return new object[] 		{ 			nameof(TwoGenericParameters_TwoUsed_TwoParameters), 			new object[] { new int[1], new string[1] }, 			new Type[] { typeof(int[]), typeof(string[]) } 		};  		// Method<T, U>(T, int) 		yield return new object[] 		{ 			nameof(TwoGenericParameters_FirstUsedFirst_TwoParameters), 			new object[] { ""5"", 5 }, 			new Type[] { typeof(string), typeof(object) } 		};  		// Method<T, U>(U, int) 		yield return new object[] 		{ 			nameof(TwoGenericParameters_SecondUsedFirst_TwoParameters), 			new object[] { ""5"", 5 }, 			new Type[] { typeof(object), typeof(string) } 		};  		// Method<T, U>(int, U) 		yield return new object[] 		{ 			nameof(TwoGenericParameters_FirstUsedSecond_TwoParameters), 			new object[] { 5, ""5"" }, 			new Type[] { typeof(string), typeof(object) } 		};  		// Method<T, U>(int, U) 		yield return new object[] 		{ 			nameof(TwoGenericParameters_SecondUsedSecond_TwoParameters), 			new object[] { 5, ""5"" }, 			new Type[] { typeof(object), typeof(string) } 		};  		// Method<T>(T[]>) 		yield return new object[] 		{ 			nameof(GenericArrayTest), 			new object[] { new int[5] }, 			new Type[] { typeof(int) } 		};  		// Method<T>(ref T>) 		yield return new object[] 		{ 			nameof(GenericRefTest), 			new object[] { ""abc"" }, 			new Type[] { typeof(string) } 		};  		// Method<T>(Generic<T>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Used), 			new object[] { new GenericClass<string>() }, 			new Type[] { typeof(string) } 		};  		// Method<T>(Generic<string>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Unused), 			new object[] { new GenericClass<string>() }, 			new Type[] { typeof(object) } 		};  		// Method(Generic<string>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric1_NoGenericParameters), 			new object[] { new GenericClass<string>() }, 			new Type[0] 		};  		// Method<T>(Generic<T[]>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Array), 			new object[] { new GenericClass<string[]>() }, 			new Type[] { typeof(string) } 		};  		// Method<T>(Generic<T?>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Nullable), 			new object[] { new GenericClass<int?>() }, 			new Type[] { typeof(int) } 		};  		// Method<T>(Generic<T>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Used), 			new object[] { new GenericClass<GenericClass<string>>() }, 			new Type[] { typeof(GenericClass<string>) } 		};  		// Method<T>(Generic<Generic<T>>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Recursive), 			new object[] { new GenericClass<GenericClass<string>>() }, 			new Type[] { typeof(string) } 		};  		// Method<T>(Generic<T>[]) 		yield return new object[] 		{ 			nameof(GenericArrayOfEmbeddedGeneric1_OneGenericParameter), 			new object[] { new GenericClass<int>[1] }, 			new Type[] { typeof(int) } 		};  		// Method<T>(T?[]) 		yield return new object[] 		{ 			nameof(GenericArrayOfGenericNullable1_OneGenericParameter), 			new object[] { new int?[1] }, 			new Type[] { typeof(int) } 		};  		// Method<T, U>(Generic2<T, U>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric2_TwoGenericParameters_SameType), 			new object[] { new GenericClass2<string, int>() }, 			new Type[] { typeof(string), typeof(int) } 		};  		// Method<T>(Generic2<T, int>) 		yield return new object[] 		{ 			nameof(EmbeddedGenericGeneric2_OneGenericParameter_First), 			new object[] { new GenericClass2<string, int>() }, 			new Type[] { typeof(string) } 		};  		// Method<T>(Generic2<string, T>) 		yield return new object[] 		{ 			nameof(EmbeddedGenericGeneric2_OneGenericParameter_Second), 			new object[] { new GenericClass2<string, int>() }, 			new Type[] { typeof(int) } 		};  		// Method<T>(Generic2<string, int>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric2_OneGeneric_Unused), 			new object[] { new GenericClass2<string, int>() }, 			new Type[] { typeof(object) } 		};  		// Method(Generic2<string, int>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric2_NotGeneric), 			new object[] { new GenericClass2<string, int>() }, 			new Type[0] 		};  		// Method<T, U>(Generic2<T, int>, Generic2<ulong, T>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest1), 			new object[] { new GenericClass2<string, int>(), new GenericClass2<ulong, long>() }, 			new Type[] { typeof(string), typeof(long) } 		};  		// Method<T, U>(Generic2<T, int>, Generic2<T, long>) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest2), 			new object[] { new GenericClass2<string, int>(), new GenericClass2<ulong, long>() }, 			new Type[] { typeof(string), typeof(ulong) } 		};  		// Method<T, U>(Generic2<string, T>, Generic2<T, long) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest3), 			new object[] { new GenericClass2<string, int>(), new GenericClass2<ulong, long>() }, 			new Type[] { typeof(int), typeof(ulong) } 		};  		// Method<T, U>(Generic2<string, T>, Generic2<ulong, T) 		yield return new object[] 		{ 			nameof(EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest4), 			new object[] { new GenericClass2<string, int>(), new GenericClass2<ulong, long>() }, 			new Type[] { typeof(int), typeof(long) } 		};  		// Stress test 		yield return new object[] 		{ 			nameof(CrazyGenericMethod), 			new object[] { new GenericClass3<GenericClass<bool>, GenericClass2<GenericClass3<ulong, long, int>, string>, uint>() }, 			new Type[] { typeof(bool), typeof(ulong), typeof(long), typeof(object), typeof(uint) } 		};  		// Func test 		yield return new object[] 		{ 			nameof(FuncTestMethod), 			new object[] { new int[] { 4, 5, 6, 7 }, 0, 0, new Func<int, float>(i => i + 0.5f) }, 			new Type[] { typeof(float) } 		};  		yield return new object[] 		{ 			nameof(FuncTestMethod), 			new object[] { new int[] { 4, 5, 6, 7 }, 0, 1, new Func<int, double>(i => i + 0.5d) }, 			new Type[] { typeof(double) } 		};  		yield return new object[] 		{ 			nameof(FuncTestMethod), 			new object[] { new int[] { 4, 5, 6, 7 }, 0, 2, new Func<int, int>(i => i) }, 			new Type[] { typeof(int) } 		}; 	}  	public static IEnumerable<object[]> ResolveGenericType_MismatchedGenericTypeArguments_TestData() 	{ 		// SubClass: GenericBaseClass<int> -> GenericBaseClass<T> 		yield return new object[] 		{ 			nameof(OneGenericParameter_GenericBaseClass), 			new object[] { new ImplementsGeneric1BaseClass() }, 			new Type[] { typeof(int) } 		};  		// SubClass: BaseClass<int, string> -> BaseClass<T, U> 		yield return new object[] 		{ 			nameof(TwoGenericParameters_GenericBaseClass), 			new object[] { new ImplementsGeneric2BaseClass() }, 			new Type[] { typeof(int), typeof(uint) } 		};  		// SubClass<T>: BaseClass<T, string> -> BaseClass<T, U> 		yield return new object[] 		{ 			nameof(TwoGenericParameters_GenericBaseClass), 			new object[] { new GenericImplements2BaseClass<int>() }, 			new Type[] { typeof(int), typeof(string) } 		};  		// Class: Interface<int> -> Interface<T> 		yield return new object[] 		{ 			nameof(OneGenericParameter_GenericInterface), 			new object[] { new ImplementsGeneric1Interface() }, 			new Type[] { typeof(int) } 		};  		// Class: Interface<int, string> -> Interface<T, U> 		yield return new object[] 		{ 			nameof(TwoGenericParameters_GenericInterface), 			new object[] { new ImplementsGeneric2Interface() }, 			new Type[] { typeof(int), typeof(uint) } 		};  		// Class<T>: Interface<T, string> -> Interface<T, U> 		yield return new object[] 		{ 			nameof(TwoGenericParameters_GenericInterface), 			new object[] { new GenericImplements2Interface<int>() }, 			new Type[] { typeof(int), typeof(string) } 		}; 	}  	[Theory] 	[MemberData(nameof(ResolveGenericType_TestData))] 	[MemberData(nameof(ResolveGenericType_MismatchedGenericTypeArguments_TestData))] 	public static void ResolveGenericType(string methodName, object[] parameters, Type[] expected) 	{ 		IMethodInfo method = Reflector.Wrap(typeof(ResolveGenericMethodTests).GetMethod(methodName)); 		Type[] actual = method.ResolveGenericTypes(parameters).Select(t => ((ReflectionTypeInfo)t).Type).ToArray(); 		Assert.Equal(expected, actual); 	}  	public static void NoGenericParameters_NoParameters() { } 	public static void NoGenericParameters_OneParameter(int i) { } 	public static void OneGenericParameter_NotUsed_NoParameters<T>() { } 	public static void OneGenericParameter_NotUsed_OneParameter<T>(int i) { } 	public static void TwoGenericParameters_NoneUsed_NoParameters<T, U>() { } 	public static void TwoGenericParameters_NoneUsed_OneParameter<T, U>(int i) { } 	public static void TwoGenericParameters_NoneUsed_TwoParameters<T, U>(int i, long l) { }  	public static void OneGenericParameter_Used_OneParameter<T>(T t) { } 	public static void OneGenericParameter_UsedTwice_TwoParameters<T>(T t1, T t2) { } 	public static void OneGenericParameter_UsedOnceFirst_TwoParameters<T>(T t1, int i) { } 	public static void OneGenericParameter_UsedOnceSecond_TwoParameters<T>(int i, T t1) { }  	public static void TwoGenericParameters_OnlyFirstUsed_TwoParameters<T, U>(T t1, T t2) { } 	public static void TwoGenericParameters_OnlySecondUsed_TwoParameters<T, U>(U u1, U u) { } 	public static void TwoGenericParameters_OnlyFirstUsed_OneParameter<T, U>(T t) { } 	public static void TwoGenericParameters_OnlySecondUsed_OneParameter<T, U>(U u) { } 	public static void TwoGenericParameters_TwoUsed_TwoParameters<T, U>(T t, U u) { } 	public static void TwoGenericParameters_FirstUsedFirst_TwoParameters<T, U>(T t, int i) { } 	public static void TwoGenericParameters_SecondUsedFirst_TwoParameters<T, U>(U u, int i) { } 	public static void TwoGenericParameters_FirstUsedSecond_TwoParameters<T, U>(int i, T t) { } 	public static void TwoGenericParameters_SecondUsedSecond_TwoParameters<T, U>(int i, U u) { }  	public static void GenericArrayTest<T>(T[] value) { }  	public static void GenericRefTest<T>(ref T value) { }  	public static void EmbeddedGeneric1_OneGenericParameter_Used<T>(GenericClass<T> value) { } 	public static void EmbeddedGeneric1_OneGenericParameter_Unused<T>(GenericClass<string> value) { } 	public static void EmbeddedGeneric1_NoGenericParameters(GenericClass<string> value) { }  	public static void EmbeddedGeneric1_OneGenericParameter_Array<T>(GenericClass<T[]> generic) { } 	public static void EmbeddedGeneric1_OneGenericParameter_Nullable<T>(GenericClass<T?> generic) where T : struct { }  	public static void EmbeddedGeneric1_OneGenericParameter_Recursive<T>(GenericClass<GenericClass<T>> generic) { }  	public static void GenericArrayOfEmbeddedGeneric1_OneGenericParameter<T>(GenericClass<T>[] generic) { } 	public static void GenericArrayOfGenericNullable1_OneGenericParameter<T>(T?[] generic) where T : struct { }  	public static void EmbeddedGeneric2_TwoGenericParameters_SameType<T, U>(GenericClass2<T, U> t) { } 	public static void EmbeddedGenericGeneric2_OneGenericParameter_First<T>(GenericClass2<T, int> t) { } 	public static void EmbeddedGenericGeneric2_OneGenericParameter_Second<T>(GenericClass2<string, T> t) { }  	public static void EmbeddedGeneric2_OneGeneric_Unused<T>(GenericClass2<string, int> t) { } 	public static void EmbeddedGeneric2_NotGeneric(GenericClass2<string, int> t) { }  	public static void EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest1<T, U>(GenericClass2<T, int> t1, GenericClass2<ulong, U> t2) { } 	public static void EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest2<T, U>(GenericClass2<T, int> t1, GenericClass2<U, long> t2) { } 	public static void EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest3<T, U>(GenericClass2<string, T> t1, GenericClass2<U, long> t2) { } 	public static void EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest4<T, U>(GenericClass2<string, T> t1, GenericClass2<ulong, U> t2) { }  	public static void CrazyGenericMethod<T, U, V, W, X>(GenericClass3<GenericClass<T>, GenericClass2<GenericClass3<U, V, int>, string>, X> gen) { }  	public static void FuncTestMethod<TResult>(IEnumerable<int> source, int start, int length, Func<int, TResult> selector) { }  	public static void OneGenericParameter_GenericBaseClass<T>(GenericClass<T> x) { } 	public static void TwoGenericParameters_GenericBaseClass<T, U>(GenericClass2<T, U> x) { }  	public static void OneGenericParameter_GenericInterface<T>(Generic1Interface<T> x) { } 	public static void TwoGenericParameters_GenericInterface<T, U>(Generic2Interface<T, U> x) { }  	public class GenericClass<T> { } 	public class GenericClass2<T, U> { } 	public class GenericClass3<T, U, V> { }  	public interface Generic1Interface<T> { } 	public interface Generic2Interface<T, U> { }  	public class ImplementsGeneric1BaseClass : GenericClass<int> { } 	public class ImplementsGeneric2BaseClass : GenericClass2<int, uint> { }  	public class ImplementsGeneric1Interface : Generic1Interface<int> { } 	public class ImplementsGeneric2Interface : Generic2Interface<int, uint> { }  	public class GenericImplements2BaseClass<T> : GenericClass2<T, string> { } 	public class GenericImplements2Interface<T> : Generic2Interface<T, string> { } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.common\FailureCause.cs,"namespace Xunit.Sdk;  /// <summary> /// Indicates the cause of the test failure. /// </summary> public enum FailureCause { 	/// <summary> 	/// Indicates that a test failed for some reason other than a typical execution failure 	/// (for example, if a test was skipped but the flag was given to fail all skipped tests). 	/// </summary> 	Other = 0,  	/// <summary> 	/// Indicates that the test failed because it threw an unhandled exception. 	/// </summary> 	Exception = 1,  	/// <summary> 	/// Indicates that the test failed because of an assertion failure (that is, an exception 	/// was thrown that implements an interface named IAssertionException, regardless of the 	/// namespace or source assembly of the interface). For built-in exceptions, the 	/// <see cref=""T:Xunit.Sdk.IAssertionException""/> serves this purpose, but this is generally 	/// found by convention rather than type to prevent 3rd party assertion libraries from needing 	/// to take an explicit references to xUnit.net binaries. 	/// </summary> 	Assertion = 2,  	/// <summary> 	/// Indicates that the test failed because it exceeded the allowed time to run (typically 	/// specified via <see cref=""P:Xunit.FactAttribute.Timeout""/>). This is indicated by an 	/// exception that is thrown which implements an interface named ITestTimeoutException, regardless 	/// of the namespace or source assembly of the interface. For FactAttribute, the 	/// <see cref=""T:Xunit.Sdk.ITestTimeoutException""/> serves this purpose, but this is generally 	/// found by convention rather than type to prevent 3rd party libraries from needing to 	/// take an explicit reference to xUnit.net binaries. 	/// </summary> 	Timeout = 3, }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\AssemblyFixtureAttribute.cs,"#pragma warning disable CA1019 // The attribute arguments are always read via reflection #pragma warning disable CA1813 // This attribute is unsealed because it's an extensibility point  using System;  namespace Xunit;  /// <summary> /// Used to decorate xUnit.net test assemblies to indicate per-assembly fixture data. An instance of /// the fixture data is initialized before any test in the assembly are run (including /// <see cref=""IAsyncLifetime.InitializeAsync""/> if it's implemented). After all the tests in the /// assembly have been run, it is cleaned up by calling <see cref=""IAsyncDisposable.DisposeAsync""/> /// if it's implemented, or it falls back to <see cref=""IDisposable.Dispose""/> if that's implemented. /// Assembly fixtures must have a public parameterless constructor. To gain access to the fixture data /// from inside the test, a constructor argument should be added to the test class which exactly /// matches the fixture type. /// </summary> [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)] public class AssemblyFixtureAttribute : Attribute { 	/// <summary> 	/// Initializes a new instance of the <see cref=""AssemblyFixtureAttribute""/> class. 	/// </summary> 	/// <param name=""assemblyFixtureType"">The assembly fixture class type</param> 	public AssemblyFixtureAttribute(Type assemblyFixtureType) 	{ } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\AssemblyTraitAttribute.cs,"using System;  namespace Xunit;  /// <summary> /// This class has been deprecated. Use <see cref=""TraitAttribute""/> instead. /// </summary> [Obsolete(""This class has been deprecated. Use Xunit.TraitAttribute instead"", error: true)] [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)] public sealed class AssemblyTraitAttribute : Attribute { }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\ClassDataAttribute.cs,"#pragma warning disable CA1813 // This attribute is unsealed because it's an extensibility point  using System; using System.Collections; using System.Collections.Generic; using System.Globalization; using System.Reflection; using System.Threading.Tasks; using Xunit.Internal; using Xunit.Sdk;  namespace Xunit;  /// <summary> /// Provides a data source for a data theory, with the data coming from a class /// which must implement IEnumerable&lt;object?[]&gt;. /// </summary> [DataDiscoverer(typeof(ClassDataDiscoverer))] [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public class ClassDataAttribute : DataAttribute { 	/// <summary> 	/// Initializes a new instance of the <see cref=""ClassDataAttribute""/> class. 	/// </summary> 	/// <param name=""class"">The class that provides the data.</param> 	public ClassDataAttribute(Type @class) 	{ 		Class = @class; 	}  	/// <summary> 	/// Gets the type of the class that provides the data. 	/// </summary> 	public Type Class { get; }  	/// <inheritdoc/> 	protected override ITheoryDataRow ConvertDataRow( 		MethodInfo testMethod, 		object dataRow) 	{ 		Guard.ArgumentNotNull(testMethod); 		Guard.ArgumentNotNull(dataRow);  		try 		{ 			return base.ConvertDataRow(testMethod, dataRow); 		} 		catch (ArgumentException) 		{ 			throw new ArgumentException( 				string.Format( 					CultureInfo.CurrentCulture, 					""Class '{0}' yielded an item of type '{1}' which is not an 'object?[]', 'Xunit.ITheoryDataRow' or 'System.Runtime.CompilerServices.ITuple'"", 					Class.FullName, 					dataRow?.GetType().SafeName() 				), 				nameof(dataRow) 			); 		} 	}  	/// <inheritdoc/> 	public override async ValueTask<IReadOnlyCollection<ITheoryDataRow>?> GetData( 		MethodInfo testMethod, 		DisposalTracker disposalTracker) 	{ 		Guard.ArgumentNotNull(testMethod); 		Guard.ArgumentNotNull(disposalTracker);  		var classInstance = Activator.CreateInstance(Class); 		disposalTracker.Add(classInstance);  		if (classInstance is IAsyncLifetime classLifetime) 			await classLifetime.InitializeAsync();  		if (classInstance is IEnumerable dataItems) 		{ 			var result = new List<ITheoryDataRow>();  			foreach (var dataItem in dataItems) 				if (dataItem is not null) 					result.Add(ConvertDataRow(testMethod, dataItem));  			return result.CastOrToReadOnlyCollection(); 		}  		if (classInstance is IAsyncEnumerable<object?> asyncDataItems) 		{ 			var result = new List<ITheoryDataRow>();  			await foreach (var dataItem in asyncDataItems) 				if (dataItem is not null) 					result.Add(ConvertDataRow(testMethod, dataItem));  			return result.CastOrToReadOnlyCollection(); 		}  		throw new ArgumentException( 			string.Format( 				CultureInfo.CurrentCulture, 				""'{0}' must implement one of the following interfaces to be used as ClassData for the test method named '{1}' on '{2}':{3}- IEnumerable<ITheoryDataRow>{3}- IEnumerable<object[]>{3}- IAsyncEnumerable<ITheoryDataRow>{3}- IAsyncEnumerable<object[]>"", 				Class.FullName, 				testMethod.Name, 				testMethod.DeclaringType?.FullName, 				Environment.NewLine 			) 		); 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\CollectionAttribute.cs,"#pragma warning disable CA1019 // The attribute arguments are always read via reflection  using System;  namespace Xunit;  /// <summary> /// Used to declare a specific test collection for a test class. /// </summary> [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)] public sealed class CollectionAttribute : Attribute { 	/// <summary> 	/// Initializes a new instance of the <see cref=""CollectionAttribute"" /> class. 	/// </summary> 	/// <param name=""name"">The test collection name.</param> 	public CollectionAttribute(string name) 	{ } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\CollectionBehavior.cs,"namespace Xunit;  /// <summary> /// Defines the built-in behavior types for collections in xUnit.net. /// </summary> public enum CollectionBehavior { 	/// <summary> 	/// By default, generates a collection per assembly, and any test classes that are not 	/// decorated with <see cref=""CollectionAttribute""/> will be placed into the assembly-level 	/// collection. 	/// </summary> 	CollectionPerAssembly,  	/// <summary> 	/// By default, generates a collection per test class for any test classes that are not 	/// decorated with <see cref=""CollectionAttribute""/>. 	/// </summary> 	CollectionPerClass }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\CollectionBehaviorAttribute.cs,"#pragma warning disable CA1019 // The attribute arguments are always read via reflection  using System;  namespace Xunit;  /// <summary> /// Used to declare the default test collection behavior for the assembly. /// </summary> [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)] public sealed class CollectionBehaviorAttribute : Attribute { 	/// <summary> 	/// Initializes a new instance of the <see cref=""CollectionBehaviorAttribute"" /> class. 	/// </summary> 	public CollectionBehaviorAttribute() 	{ }  	/// <summary> 	/// Initializes a new instance of the <see cref=""CollectionBehaviorAttribute"" /> class. 	/// </summary> 	/// <param name=""collectionBehavior"">The collection behavior for the assembly.</param> 	public CollectionBehaviorAttribute(CollectionBehavior collectionBehavior) 	{ }  	/// <summary> 	/// Initializes a new instance of the <see cref=""CollectionBehaviorAttribute"" /> class. 	/// </summary> 	/// <param name=""factoryTypeName"">The type name of the test collection factory (that implements <see cref=""T:Xunit.Sdk.IXunitTestCollectionFactory""/>).</param> 	/// <param name=""factoryAssemblyName"">The assembly that <paramref name=""factoryTypeName""/> exists in.</param> 	public CollectionBehaviorAttribute( 		string factoryTypeName, 		string factoryAssemblyName) 	{ }  	/// <summary> 	/// Initializes a new instance of the <see cref=""CollectionBehaviorAttribute"" /> class. 	/// </summary> 	/// <param name=""factoryType"">The factory type</param> 	public CollectionBehaviorAttribute(Type factoryType) 	{ }  	/// <summary> 	/// Determines whether tests in this assembly are run in parallel. 	/// </summary> 	public bool DisableTestParallelization { get; set; }  	/// <summary> 	/// Determines how many tests can run in parallel with each other. If set to 0, the system will 	/// use <see cref=""Environment.ProcessorCount""/>. If set to a negative number, then there will 	/// be no limit to the number of threads. 	/// </summary> 	public int MaxParallelThreads { get; set; } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\CollectionDefinitionAttribute.cs,"#pragma warning disable CA1019 // The attribute arguments are always read via reflection  using System;  namespace Xunit;  /// <summary> /// Used to declare a test collection container class. The container class gives /// developers a place to attach interfaces like <see cref=""IClassFixture{T}""/> and /// <see cref=""ICollectionFixture{T}""/> that will be applied to all tests classes /// that are members of the test collection. /// </summary> [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)] public sealed class CollectionDefinitionAttribute : Attribute { 	/// <summary> 	/// Initializes a new instance of the <see cref=""CollectionDefinitionAttribute"" /> class. 	/// </summary> 	/// <param name=""name"">The test collection name.</param> 	public CollectionDefinitionAttribute(string name) 	{ }  	/// <summary> 	/// Determines whether tests in this collection runs in parallel with any other collections. 	/// </summary> 	public bool DisableParallelization { get; set; } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\FactAttribute.cs,"#pragma warning disable CA1813 // This attribute is unsealed because it's an extensibility point  using System; using Xunit.Sdk;  namespace Xunit;  /// <summary> /// Attribute that is applied to a method to indicate that it is a fact that should be run /// by the test runner. It can also be extended to support a customized definition of a /// test method. /// </summary> [XunitTestCaseDiscoverer(typeof(FactDiscoverer))] [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class FactAttribute : Attribute { 	/// <summary> 	/// Gets the name of the test to be used when the test is skipped. Defaults to 	/// <c>null</c>, which will cause the fully qualified test name to be used. 	/// </summary> 	public virtual string? DisplayName { get; set; }  	/// <summary> 	/// Gets or sets a flag which indicates that this is an explicit test, and will normally 	/// be skipped unless it is requested to be explicitly run. (The mechanism for requesting 	/// to run explicit tests will vary from runner to runner; the command-line runners support 	/// an ""-explicit"" option.) 	/// </summary> 	public virtual bool Explicit { get; set; }  	/// <summary> 	/// A non-<c>null</c> value marks the test so that it will not be run with the given 	/// string value as the skip reason. 	/// </summary> 	public virtual string? Skip { get; set; }  	/// <summary> 	/// A value greater than zero marks the test as having a timeout, and gets or sets the 	/// timeout (in milliseconds). 	/// </summary> 	/// <remarks> 	/// WARNING: Using this with parallelization turned on will result in undefined behavior. 	/// Timeout is only supported when parallelization is disabled, either globally or with 	/// a parallelization-disabled test collection. 	/// </remarks> 	public virtual int Timeout { get; set; } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\IAsyncLifetime.cs,"using System; using System.Threading.Tasks;  namespace Xunit;  /// <summary> /// Used to provide asynchronous lifetime functionality. Currently supported:<br /> /// - Test classes<br /> /// - Classes used in <see cref=""IClassFixture{TFixture}""/><br /> /// - Classes used in <see cref=""ICollectionFixture{TFixture}""/>.<br /> /// - Classes used in <c>[assembly: <see cref=""AssemblyFixtureAttribute""/>()]</c>. /// </summary> public interface IAsyncLifetime : IAsyncDisposable { 	/// <summary> 	/// Called immediately after the class has been created, before it is used. 	/// </summary> 	ValueTask InitializeAsync(); }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\IClassFixture.cs,"#pragma warning disable CA1040 // The only data this interface needs to convey is the generic type  using System;  namespace Xunit;  /// <summary> /// Used to decorate xUnit.net test classes and collections to indicate a test which has /// per-test-class fixture data. An instance of the fixture data is initialized just before /// the first test in the class is run (including <see cref=""IAsyncLifetime.InitializeAsync""/> /// if it's implemented). After all the tests in the test class have been run, it is cleaned up /// by calling <see cref=""IAsyncDisposable.DisposeAsync""/> if it's implemented, or it falls back /// to <see cref=""IDisposable.Dispose""/> if that's implemented. Class fixtures may have /// a public constructor which is either empty, or accepts one or more assembly and/or collection /// fixture objects as constructor arguments. To gain access to the fixture data from inside the /// test, a constructor argument should be added to the test class which/ exactly matches the /// <typeparamref name=""TFixture""/>. /// </summary> /// <typeparam name=""TFixture"">The type of the fixture.</typeparam> public interface IClassFixture<TFixture> 	where TFixture : class { }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\ICollectionFixture.cs,"#pragma warning disable CA1040 // The only data this interface needs to convey is the generic type  using System;  namespace Xunit;  /// <summary> /// Used to decorate xUnit.net test classes and collections to indicate a test which has /// per-test-collection fixture data. An instance of the fixture data is initialized just before /// the first test in the collection is run (including <see cref=""IAsyncLifetime.InitializeAsync""/> /// if it's implemented). After all the tests in the collection have been run, it is cleaned up /// by calling <see cref=""IAsyncDisposable.DisposeAsync""/> if it's implemented, or it falls back /// to <see cref=""IDisposable.Dispose""/> if that's implemented. Collection fixtures may have /// a public constructor which is either empty, or accepts one or more assembly fixture objects /// as constructor arguments. To gain access to the fixture data from inside the test, a constructor /// argument should be added to the test class which exactly matches the <typeparamref name=""TFixture""/>. /// </summary> /// <typeparam name=""TFixture"">The type of the fixture.</typeparam> public interface ICollectionFixture<TFixture> 	where TFixture : class { }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\InlineDataAttribute.cs,"#pragma warning disable CA1019 // The attribute arguments are always read via reflection  using System; using System.Collections.Generic; using System.Reflection; using System.Threading.Tasks; using Xunit.Sdk;  namespace Xunit;  /// <summary> /// Provides a data source for a data theory, with the data coming from inline values. /// </summary> [DataDiscoverer(typeof(InlineDataDiscoverer))] [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public sealed class InlineDataAttribute : DataAttribute { 	readonly object?[] data;  	/// <summary> 	/// Initializes a new instance of the <see cref=""InlineDataAttribute""/> class. 	/// </summary> 	/// <param name=""data"">The data values to pass to the theory.</param> 	public InlineDataAttribute(params object?[] data) 	{ 		this.data = data; 	}  	/// <inheritdoc/> 	public override ValueTask<IReadOnlyCollection<ITheoryDataRow>?> GetData( 		MethodInfo testMethod, 		DisposalTracker disposalTracker) => 			new(new[] { new TheoryDataRow(data) }); }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\ITestContextAccessor.cs,"namespace Xunit;  /// <summary> /// Gives access to the current test context, which is considered to be an immutable snapshot of /// the current test state at the time it's retrieved. /// </summary> public interface ITestContextAccessor { 	/// <summary> 	/// Gets a snapshot of the current state of test execution. 	/// </summary> 	TestContext? Current { get; } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\ITheoryDataRow.cs,"using System.Collections.Generic; using Xunit.Sdk; using Xunit.v3;  namespace Xunit;  /// <summary> /// Represents a single row of theory data, along with optional metadata attached to the row. /// </summary> public interface ITheoryDataRow { 	/// <summary> 	/// Gets a flag that indicates that the data row should only be run explicitly. If the value is <c>null</c>, 	/// then it inherits its explicitness from the value of <see cref=""FactAttribute.Explicit""/>. 	/// </summary> 	bool? Explicit { get; }  	/// <summary> 	/// Gets the reason for skipping this row of data; if <c>null</c> is returned, then the data 	/// row isn't skipped. 	/// </summary> 	string? Skip { get; }  	/// <summary> 	/// Gets the display name for the test (replacing the default behavior, which would be to 	/// use <see cref=""DataAttribute.TestDisplayName""/> or <see cref=""FactAttribute.DisplayName""/>, 	/// or falling back to the default test display name based on <see cref=""TestMethodDisplay""/> 	/// and <see cref=""TestMethodDisplayOptions""/> in the configuration file). 	/// </summary> 	string? TestDisplayName { get; }  	/// <summary> 	/// A value greater than zero marks the test as having a timeout, and gets or sets the 	/// timeout (in milliseconds). A non-<c>null</c> value here overrides any inherited value 	/// from the <see cref=""DataAttribute""/> or the <see cref=""TheoryAttribute""/>. 	/// </summary> 	/// <remarks> 	/// WARNING: Using this with parallelization turned on will result in undefined behavior. 	/// Timeout is only supported when parallelization is disabled, either globally or with 	/// a parallelization-disabled test collection. 	/// </remarks> 	int? Timeout { get; }  	/// <summary> 	/// Gets the trait values associated with this theory data row. If there are none, you may either 	/// return a <c>null</c> or empty dictionary. 	/// </summary> 	Dictionary<string, List<string>>? Traits { get; }  	/// <summary> 	/// Gets the theory data. 	/// </summary> 	object?[] GetData(); }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\MatrixTheoryData.cs,"using System.Collections.Generic; using Xunit.Internal;  namespace Xunit;  /// <summary> /// Represents theory data which is created from the merging of two data streams by /// creating a matrix of the data. /// </summary> /// <typeparam name=""T1"">Type of the first data dimension</typeparam> /// <typeparam name=""T2"">Type of the second data dimension</typeparam> public class MatrixTheoryData<T1, T2> : TheoryData<T1, T2> { 	/// <summary> 	/// Initializes a new instance of the <see cref=""MatrixTheoryData{T1, T2}""/> class. 	/// </summary> 	/// <param name=""dimension1"">Data for the first dimension</param> 	/// <param name=""dimension2"">Data for the second dimension</param> 	public MatrixTheoryData( 		IEnumerable<T1> dimension1, 		IEnumerable<T2> dimension2) 	{ 		Guard.ArgumentNotNull(dimension1); 		Guard.ArgumentNotNull(dimension2);  		var data1Empty = true; 		var data2Empty = true;  		foreach (var t1 in dimension1) 		{ 			data1Empty = false;  			foreach (var t2 in dimension2) 			{ 				data2Empty = false; 				Add(t1, t2); 			} 		}  		Guard.ArgumentValid(""Data dimension cannot be empty"", !data1Empty, nameof(dimension1)); 		Guard.ArgumentValid(""Data dimension cannot be empty"", !data2Empty, nameof(dimension2)); 	} }  /// <summary> /// Represents theory data which is created from the merging of three data streams by /// creating a matrix of the data. /// </summary> /// <typeparam name=""T1"">Type of the first data dimension</typeparam> /// <typeparam name=""T2"">Type of the second data dimension</typeparam> /// <typeparam name=""T3"">Type of the third data dimension</typeparam> public class MatrixTheoryData<T1, T2, T3> : TheoryData<T1, T2, T3> { 	/// <summary> 	/// Initializes a new instance of the <see cref=""MatrixTheoryData{T1, T2, T3}""/> class. 	/// </summary> 	/// <param name=""dimension1"">Data for the first dimension</param> 	/// <param name=""dimension2"">Data for the second dimension</param> 	/// <param name=""dimension3"">Data for the third dimension</param> 	public MatrixTheoryData( 		IEnumerable<T1> dimension1, 		IEnumerable<T2> dimension2, 		IEnumerable<T3> dimension3) 	{ 		Guard.ArgumentNotNull(dimension1); 		Guard.ArgumentNotNull(dimension2); 		Guard.ArgumentNotNull(dimension3);  		var data1Empty = true; 		var data2Empty = true; 		var data3Empty = true;  		foreach (var t1 in dimension1) 		{ 			data1Empty = false;  			foreach (var t2 in dimension2) 			{ 				data2Empty = false;  				foreach (var t3 in dimension3) 				{ 					data3Empty = false; 					Add(t1, t2, t3); 				} 			} 		}  		Guard.ArgumentValid(""Data dimension cannot be empty"", !data1Empty, nameof(dimension1)); 		Guard.ArgumentValid(""Data dimension cannot be empty"", !data2Empty, nameof(dimension2)); 		Guard.ArgumentValid(""Data dimension cannot be empty"", !data3Empty, nameof(dimension3)); 	} }  /// <summary> /// Represents theory data which is created from the merging of four data streams by /// creating a matrix of the data. /// </summary> /// <typeparam name=""T1"">Type of the first data dimension</typeparam> /// <typeparam name=""T2"">Type of the second data dimension</typeparam> /// <typeparam name=""T3"">Type of the third data dimension</typeparam> /// <typeparam name=""T4"">Type of the fourth data dimension</typeparam> public class MatrixTheoryData<T1, T2, T3, T4> : TheoryData<T1, T2, T3, T4> { 	/// <summary> 	/// Initializes a new instance of the <see cref=""MatrixTheoryData{T1, T2, T3, T4}""/> class. 	/// </summary> 	/// <param name=""dimension1"">Data for the first dimension</param> 	/// <param name=""dimension2"">Data for the second dimension</param> 	/// <param name=""dimension3"">Data for the third dimension</param> 	/// <param name=""dimension4"">Data for the fourth dimension</param> 	public MatrixTheoryData( 		IEnumerable<T1> dimension1, 		IEnumerable<T2> dimension2, 		IEnumerable<T3> dimension3, 		IEnumerable<T4> dimension4) 	{ 		Guard.ArgumentNotNull(dimension1); 		Guard.ArgumentNotNull(dimension2); 		Guard.ArgumentNotNull(dimension3); 		Guard.ArgumentNotNull(dimension4);  		var data1Empty = true; 		var data2Empty = true; 		var data3Empty = true; 		var data4Empty = true;  		foreach (var t1 in dimension1) 		{ 			data1Empty = false;  			foreach (var t2 in dimension2) 			{ 				data2Empty = false;  				foreach (var t3 in dimension3) 				{ 					data3Empty = false;  					foreach (var t4 in dimension4) 					{ 						data4Empty = false; 						Add(t1, t2, t3, t4); 					} 				} 			} 		}  		Guard.ArgumentValid(""Data dimension cannot be empty"", !data1Empty, nameof(dimension1)); 		Guard.ArgumentValid(""Data dimension cannot be empty"", !data2Empty, nameof(dimension2)); 		Guard.ArgumentValid(""Data dimension cannot be empty"", !data3Empty, nameof(dimension3)); 		Guard.ArgumentValid(""Data dimension cannot be empty"", !data4Empty, nameof(dimension4)); 	} }  /// <summary> /// Represents theory data which is created from the merging of five data streams by /// creating a matrix of the data. /// </summary> /// <typeparam name=""T1"">Type of the first data dimension</typeparam> /// <typeparam name=""T2"">Type of the second data dimension</typeparam> /// <typeparam name=""T3"">Type of the third data dimension</typeparam> /// <typeparam name=""T4"">Type of the fourth data dimension</typeparam> /// <typeparam name=""T5"">Type of the fifth data dimension</typeparam> public class MatrixTheoryData<T1, T2, T3, T4, T5> : TheoryData<T1, T2, T3, T4, T5> { 	/// <summary> 	/// Initializes a new instance of the <see cref=""MatrixTheoryData{T1, T2, T3, T4, T5}""/> class. 	/// </summary> 	/// <param name=""dimension1"">Data for the first dimension</param> 	/// <param name=""dimension2"">Data for the second dimension</param> 	/// <param name=""dimension3"">Data for the third dimension</param> 	/// <param name=""dimension4"">Data for the fourth dimension</param> 	/// <param name=""dimension5"">Data for the fifth dimension</param> 	public MatrixTheoryData( 		IEnumerable<T1> dimension1, 		IEnumerable<T2> dimension2, 		IEnumerable<T3> dimension3, 		IEnumerable<T4> dimension4, 		IEnumerable<T5> dimension5) 	{ 		Guard.ArgumentNotNull(dimension1); 		Guard.ArgumentNotNull(dimension2); 		Guard.ArgumentNotNull(dimension3); 		Guard.ArgumentNotNull(dimension4); 		Guard.ArgumentNotNull(dimension5);  		var data1Empty = true; 		var data2Empty = true; 		var data3Empty = true; 		var data4Empty = true; 		var data5Empty = true;  		foreach (var t1 in dimension1) 		{ 			data1Empty = false;  			foreach (var t2 in dimension2) 			{ 				data2Empty = false;  				foreach (var t3 in dimension3) 				{ 					data3Empty = false;  					foreach (var t4 in dimension4) 					{ 						data4Empty = false;  						foreach (var t5 in dimension5) 						{ 							data5Empty = false; 							Add(t1, t2, t3, t4, t5); 						} 					} 				} 			} 		}  		Guard.ArgumentValid(""Data dimension cannot be empty"", !data1Empty, nameof(dimension1)); 		Guard.ArgumentValid(""Data dimension cannot be empty"", !data2Empty, nameof(dimension2)); 		Guard.ArgumentValid(""Data dimension cannot be empty"", !data3Empty, nameof(dimension3)); 		Guard.ArgumentValid(""Data dimension cannot be empty"", !data4Empty, nameof(dimension4)); 		Guard.ArgumentValid(""Data dimension cannot be empty"", !data5Empty, nameof(dimension5)); 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\MemberDataAttribute.cs,"using System; using Xunit.Sdk;  namespace Xunit;  /// <summary> /// Provides a data source for a data theory, with the data coming from one of the following sources: /// 1. A static property /// 2. A static field /// 3. A static method (with parameters) /// The member must return something compatible with IEnumerable&lt;object?[]&gt; with the test data. /// </summary> [DataDiscoverer(typeof(MemberDataDiscoverer))] [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class MemberDataAttribute : MemberDataAttributeBase { 	/// <summary> 	/// Initializes a new instance of the <see cref=""MemberDataAttribute""/> class. 	/// </summary> 	/// <param name=""memberName"">The name of the public static member on the test class that will provide the test data</param> 	/// <param name=""arguments"">The arguments to be passed to the member (only supported for methods; ignored for everything else)</param> 	public MemberDataAttribute( 		string memberName, 		params object?[] arguments) 			: base(memberName, arguments) 	{ } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\MemberDataAttributeBase.cs,"using System; using System.Collections; using System.Collections.Generic; using System.Globalization; using System.Linq; using System.Reflection; using System.Threading.Tasks; using Xunit.Internal; using Xunit.Sdk;  namespace Xunit;  /// <summary> /// Provides a base class for attributes that will provide member data. The member data must return /// something compatible with <see cref=""IEnumerable""/>. /// </summary> [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public abstract class MemberDataAttributeBase : DataAttribute { 	static readonly Lazy<string> supportedDataSignatures;  	static MemberDataAttributeBase() 	{ 		supportedDataSignatures = new(() => 		{ 			var dataSignatures = new List<string>(18);  			foreach (var enumerable in new[] { ""IEnumerable<{0}>"", ""IAsyncEnumerable<{0}>"" }) 				foreach (var dataType in new[] { ""ITheoryDataRow"", ""object[]"", ""Tuple<...>"" }) 					foreach (var wrapper in new[] { ""- {0}"", ""- Task<{0}>"", ""- ValueTask<{0}>"" }) 						dataSignatures.Add(string.Format(CultureInfo.CurrentCulture, wrapper, string.Format(CultureInfo.CurrentCulture, enumerable, dataType)));  			return string.Join(Environment.NewLine, dataSignatures); 		}); 	}  	/// <summary> 	/// Initializes a new instance of the <see cref=""MemberDataAttributeBase""/> class. 	/// </summary> 	/// <param name=""memberName"">The name of the public static member on the test class that will provide the test data</param> 	/// <param name=""arguments"">The arguments to be passed to the member (only supported for methods; ignored for everything else)</param> 	protected MemberDataAttributeBase( 		string memberName, 		object?[] arguments) 	{ 		MemberName = Guard.ArgumentNotNull(memberName); 		Arguments = Guard.ArgumentNotNull(arguments); 	}  	/// <summary> 	/// Gets or sets the arguments passed to the member. Only supported for static methods. 	/// </summary> 	public object?[] Arguments { get; }  	/// <summary> 	/// Returns <c>true</c> if the data attribute wants to skip enumerating data during discovery. 	/// This will cause the theory to yield a single test case for all data, and the data discovery 	/// will be during test execution instead of discovery. 	/// </summary> 	public bool DisableDiscoveryEnumeration { get; set; }  	/// <summary> 	/// Gets the member name. 	/// </summary> 	public string MemberName { get; }  	/// <summary> 	/// Gets or sets the type to retrieve the member from. If not set, then the property will be 	/// retrieved from the unit test class. 	/// </summary> 	public Type? MemberType { get; set; }  	/// <inheritdoc/> 	protected override ITheoryDataRow ConvertDataRow( 		MethodInfo testMethod, 		object dataRow) 	{ 		Guard.ArgumentNotNull(testMethod); 		Guard.ArgumentNotNull(dataRow);  		try 		{ 			return base.ConvertDataRow(testMethod, dataRow); 		} 		catch (ArgumentException) 		{ 			throw new ArgumentException( 				string.Format( 					CultureInfo.CurrentCulture, 					""Member '{0}' on '{1}' yielded an item of type '{2}' which is not an 'object?[]', 'Xunit.ITheoryDataRow' or 'System.Runtime.CompilerServices.ITuple'"", 					MemberName, 					MemberType ?? testMethod.DeclaringType, 					dataRow.GetType().SafeName() 				), 				nameof(dataRow) 			); 		} 	}  	/// <inheritdoc/> 	public override ValueTask<IReadOnlyCollection<ITheoryDataRow>?> GetData( 		MethodInfo testMethod, 		DisposalTracker disposalTracker) 	{ 		Guard.ArgumentNotNull(testMethod);  		var type = MemberType ?? testMethod.DeclaringType; 		if (type is null) 			return new(default(IReadOnlyCollection<ITheoryDataRow>));  		var accessor = GetPropertyAccessor(type) ?? GetFieldAccessor(type) ?? GetMethodAccessor(type); 		if (accessor is null) 			throw new ArgumentException( 				string.Format( 					CultureInfo.CurrentCulture, 					""Could not find public static member (property, field, or method) named '{0}' on {1}{2}"", 					MemberName, 					type.FullName, 					Arguments.Length > 0 ? string.Format(CultureInfo.CurrentCulture, "" with parameter types: {0}"", string.Join("", "", Arguments.Select(p => p?.GetType().FullName ?? ""(null)""))) : """" 				) 			);  		var returnValue = accessor(); 		if (returnValue is null) 			return new(default(IReadOnlyCollection<ITheoryDataRow>));  		if (returnValue is IEnumerable dataItems) 		{ 			var result = new List<ITheoryDataRow>();  			foreach (var dataItem in dataItems) 				if (dataItem is not null) 					result.Add(ConvertDataRow(testMethod, dataItem));  			return new(result.CastOrToReadOnlyCollection()); 		}  		return GetDataAsync(returnValue, testMethod, type); 	}  	async ValueTask<IReadOnlyCollection<ITheoryDataRow>?> GetDataAsync( 		object? returnValue, 		MethodInfo testMethod, 		Type type) 	{ 		var taskAwaitable = returnValue.AsValueTask(); 		if (taskAwaitable.HasValue) 			returnValue = await taskAwaitable.Value;  		if (returnValue is IAsyncEnumerable<object?> asyncDataItems) 		{ 			var result = new List<ITheoryDataRow>();  			await foreach (var dataItem in asyncDataItems) 				if (dataItem is not null) 					result.Add(ConvertDataRow(testMethod, dataItem));  			return result.CastOrToReadOnlyCollection(); 		}  		// Duplicate from GetData(), but it's hard to avoid since we need to support Task/ValueTask 		// of IEnumerable (and not just IAsyncEnumerable). 		if (returnValue is IEnumerable dataItems) 		{ 			var result = new List<ITheoryDataRow>();  			foreach (var dataItem in dataItems) 				if (dataItem is not null) 					result.Add(ConvertDataRow(testMethod, dataItem));  			return result.CastOrToReadOnlyCollection(); 		}  		throw new ArgumentException( 			string.Format( 				CultureInfo.CurrentCulture, 				""Member '{0}' on '{1}' must return data in one of the following formats:{2}{3}"", 				MemberName, 				type.FullName, 				Environment.NewLine, 				supportedDataSignatures.Value 			) 		); 	}  	Func<object?>? GetFieldAccessor(Type? type) 	{ 		FieldInfo? fieldInfo = null; 		for (var reflectionType = type; reflectionType is not null; reflectionType = reflectionType.BaseType) 		{ 			fieldInfo = reflectionType.GetRuntimeField(MemberName); 			if (fieldInfo is not null) 				break; 		}  		if (fieldInfo is null || !fieldInfo.IsStatic) 			return null;  		return () => fieldInfo.GetValue(null); 	}  	Func<object?>? GetMethodAccessor(Type? type) 	{ 		MethodInfo? methodInfo = null; 		var argumentTypes = Arguments is null ? Array.Empty<Type>() : Arguments.Select(p => p?.GetType()).ToArray(); 		for (var reflectionType = type; reflectionType is not null; reflectionType = reflectionType.BaseType) 		{ 			var methodInfoArray = 				reflectionType 					.GetRuntimeMethods() 					.Where(m => m.Name == MemberName && ParameterTypesCompatible(m.GetParameters(), argumentTypes)) 					.ToArray(); 			if (methodInfoArray.Length == 0) 				continue; 			if (methodInfoArray.Length == 1) 			{ 				methodInfo = methodInfoArray[0]; 				break; 			} 			methodInfo = methodInfoArray.Where(m => m.GetParameters().Length == argumentTypes.Length).FirstOrDefault(); 			if (methodInfo is not null) 				break;  			throw new ArgumentException( 				string.Format( 					CultureInfo.CurrentCulture, 					""The call to method '{0}.{1}' is ambigous between {2} different options for the given arguments."", 					type!.SafeName(), 					MemberName, 					methodInfoArray.Length 				), 				nameof(type) 			); 		}  		if (methodInfo is null || !methodInfo.IsStatic) 			return null;  		var completedArguments = Arguments ?? Array.Empty<object?>(); 		var finalMethodParameters = methodInfo.GetParameters();  		completedArguments = 			completedArguments.Length == finalMethodParameters.Length 				? completedArguments 				: completedArguments.Concat(finalMethodParameters.Skip(completedArguments.Length).Select(pi => pi.DefaultValue)).ToArray();  		return () => methodInfo.Invoke(null, completedArguments); 	}  	Func<object?>? GetPropertyAccessor(Type? type) 	{ 		PropertyInfo? propInfo = null; 		for (var reflectionType = type; reflectionType is not null; reflectionType = reflectionType.BaseType) 		{ 			propInfo = reflectionType.GetRuntimeProperty(MemberName); 			if (propInfo is not null) 				break; 		}  		if (propInfo is null || propInfo.GetMethod is null || !propInfo.GetMethod.IsStatic) 			return null;  		return () => propInfo.GetValue(null, null); 	}  	static bool ParameterTypesCompatible( 		ParameterInfo[] parameters, 		Type?[] argumentTypes) 	{ 		if (parameters.Length < argumentTypes.Length) 			return false;  		var idx = 0; 		for (; idx < argumentTypes.Length; ++idx) 			if (argumentTypes[idx] is not null && !parameters[idx].ParameterType.IsAssignableFrom(argumentTypes[idx]!)) 				return false;  		for (; idx < parameters.Length; ++idx) 			if (!parameters[idx].IsOptional) 				return false;  		return true; 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\Record.cs,"using System; using System.ComponentModel; using System.Diagnostics.CodeAnalysis; using System.Threading.Tasks; using Xunit.Internal;  namespace Xunit;  /// <summary> /// Allows the user to record actions for a test. /// </summary> public static class Record { 	/// <summary> 	/// Records any exception which is thrown by the given code. 	/// </summary> 	/// <param name=""testCode"">The code which may throw an exception.</param> 	/// <returns>Returns the exception that was thrown by the code; null, otherwise.</returns> 	public static Exception? Exception(Action testCode) 	{ 		Guard.ArgumentNotNull(testCode);  		try 		{ 			testCode(); 			return null; 		} 		catch (Exception ex) 		{ 			return ex; 		} 	}  	/// <summary> 	/// Records any exception which is thrown by the given code that has 	/// a return value. Generally used for testing property accessors. 	/// </summary> 	/// <param name=""testCode"">The code which may throw an exception.</param> 	/// <returns>Returns the exception that was thrown by the code; null, otherwise.</returns> 	public static Exception? Exception(Func<object?> testCode) 	{ 		Guard.ArgumentNotNull(testCode); 		object? testCodeResult;  		try 		{ 			testCodeResult = testCode(); 		} 		catch (Exception ex) 		{ 			return ex; 		}  		if (testCodeResult is Task || testCodeResult is ValueTask) 			throw new InvalidOperationException(""You must call Assert.ThrowsAsync, Assert.DoesNotThrowAsync, or Record.ExceptionAsync when testing async code."");  		return null; 	}  	/// <summary/> 	[EditorBrowsable(EditorBrowsableState.Never)] 	[DoesNotReturn] 	[Obsolete(""You must call Record.ExceptionAsync (and await the result) when testing async code."", true)] 	public static Exception Exception(Func<Task> testCode) => throw new NotImplementedException(""You must call Record.ExceptionAsync (and await the result) when testing async code."");  	/// <summary/> 	[EditorBrowsable(EditorBrowsableState.Never)] 	[DoesNotReturn] 	[Obsolete(""You must call Record.ExceptionAsync (and await the result) when testing async code."", true)] 	public static Exception Exception(Func<ValueTask> testCode) => throw new NotImplementedException(""You must call Record.ExceptionAsync (and await the result) when testing async code."");  	/// <summary/> 	[EditorBrowsable(EditorBrowsableState.Never)] 	[DoesNotReturn] 	[Obsolete(""You must call Record.ExceptionAsync (and await the result) when testing async code."", true)] 	public static Exception Exception<T>(Func<ValueTask<T>> testCode) => throw new NotImplementedException(""You must call Record.ExceptionAsync (and await the result) when testing async code."");  	/// <summary> 	/// Records any exception which is thrown by the given task. 	/// </summary> 	/// <param name=""testCode"">The task which may throw an exception.</param> 	/// <returns>Returns the exception that was thrown by the code; null, otherwise.</returns> 	public static async ValueTask<Exception?> ExceptionAsync(Func<Task> testCode) 	{ 		Guard.ArgumentNotNull(testCode);  		try 		{ 			await testCode(); 			return null; 		} 		catch (Exception ex) 		{ 			return ex; 		} 	}  	/// <summary> 	/// Records any exception which is thrown by the given task. 	/// </summary> 	/// <param name=""testCode"">The task which may throw an exception.</param> 	/// <returns>Returns the exception that was thrown by the code; null, otherwise.</returns> 	public static async ValueTask<Exception?> ExceptionAsync(Func<ValueTask> testCode) 	{ 		Guard.ArgumentNotNull(testCode);  		try 		{ 			await testCode(); 			return null; 		} 		catch (Exception ex) 		{ 			return ex; 		} 	}  	/// <summary> 	/// Records any exception which is thrown by the given task. 	/// </summary> 	/// <param name=""testCode"">The task which may throw an exception.</param> 	/// <typeparam name=""T"">The type of the value returned by the value task.</typeparam> 	/// <returns>Returns the exception that was thrown by the code; null, otherwise.</returns> 	public static async ValueTask<Exception?> ExceptionAsync<T>(Func<ValueTask<T>> testCode) 	{ 		Guard.ArgumentNotNull(testCode);  		try 		{ 			await testCode(); 			return null; 		} 		catch (Exception ex) 		{ 			return ex; 		} 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\TestCaseOrdererAttribute.cs,"#pragma warning disable CA1019 // The attribute arguments are always read via reflection  using System;  namespace Xunit;  /// <summary> /// Used to decorate an assembly, test collection, or test class to allow /// the use of a custom <see cref=""T:Xunit.Sdk.ITestCaseOrderer""/>. /// </summary> [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class, Inherited = true, AllowMultiple = false)] public sealed class TestCaseOrdererAttribute : Attribute { 	/// <summary> 	/// Initializes a new instance of the <see cref=""TestCaseOrdererAttribute""/> class. 	/// </summary> 	/// <param name=""ordererTypeName"">The type name of the orderer class (that implements <see cref=""T:Xunit.Sdk.ITestCaseOrderer""/>).</param> 	/// <param name=""ordererAssemblyName"">The assembly that <paramref name=""ordererTypeName""/> exists in.</param> 	public TestCaseOrdererAttribute( 		string ordererTypeName, 		string ordererAssemblyName) 	{ }  	/// <summary> 	/// Initializes a new instance of the <see cref=""TestCaseOrdererAttribute""/> class. 	/// </summary> 	/// <param name=""ordererType"">The orderer type</param> 	public TestCaseOrdererAttribute(Type ordererType) { } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\TestCollectionOrdererAttribute.cs,"#pragma warning disable CA1019 // The attribute arguments are always read via reflection  using System;  namespace Xunit;  /// <summary> /// Used to decorate an assembly to allow the use of a custom <see cref=""T:Xunit.Sdk.ITestCollectionOrderer""/>. /// </summary> [AttributeUsage(AttributeTargets.Assembly, Inherited = true, AllowMultiple = false)] public sealed class TestCollectionOrdererAttribute : Attribute { 	/// <summary> 	/// Initializes a new instance of the <see cref=""TestCollectionOrdererAttribute""/> class. 	/// </summary> 	/// <param name=""ordererTypeName"">The type name of the orderer class (that implements <see cref=""T:Xunit.Sdk.ITestCollectionOrderer""/>).</param> 	/// <param name=""ordererAssemblyName"">The assembly that <paramref name=""ordererTypeName""/> exists in.</param> 	public TestCollectionOrdererAttribute( 		string ordererTypeName, 		string ordererAssemblyName) 	{ }  	/// <summary> 	/// Initializes a new instance of the <see cref=""TestCollectionOrdererAttribute""/> class. 	/// </summary> 	/// <param name=""ordererType"">The orderer type</param> 	public TestCollectionOrdererAttribute(Type ordererType) 	{ } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\TestContext.cs,"using System.Collections.Generic; using System.Diagnostics.CodeAnalysis; using System.Globalization; using System.Threading; using Xunit.Internal; using Xunit.Sdk; using Xunit.v3;  namespace Xunit;  /// <summary> /// Represents information about the current state of the test engine. It may be available at /// various points during the execution pipeline, so consumers must always take care to ensure /// that they check for <c>null</c> values from the various properties. /// </summary> public class TestContext { 	static readonly AsyncLocal<TestContext?> local = new(); 	static readonly HashSet<TestEngineStatus> validExecutionStatuses = new() { TestEngineStatus.Initializing, TestEngineStatus.Running, TestEngineStatus.CleaningUp };  	readonly List<string>? warnings;  	TestContext( 		_IMessageSink? diagnosticMessageSink, 		_IMessageSink? internalDiagnosticMessageSink, 		TestPipelineStage pipelineStage, 		CancellationToken cancellationToken, 		List<string>? warnings = null) 	{ 		DiagnosticMessageSink = diagnosticMessageSink; 		InternalDiagnosticMessageSink = internalDiagnosticMessageSink; 		PipelineStage = pipelineStage; 		CancellationToken = cancellationToken; 		this.warnings = warnings; 	}  	/// <summary> 	/// Gets the cancellation token that is used to indicate that the test run should be 	/// aborted. Async tests should pass this along to any async functions that support 	/// cancellation tokens, to help speed up the cancellation process. 	/// </summary> 	public CancellationToken CancellationToken { get; }  	/// <summary> 	/// Gets the current test context. If called outside of the text discovery or execution path, 	/// will return <c>null</c>. The current test context is a ""snapshot in time"" for when this 	/// property is called, so do not cache the instance across a single method boundary (or else 	/// you run the risk of having an out-of-date context). 	/// </summary> 	public static TestContext? Current => local.Value;  	internal _IMessageSink? DiagnosticMessageSink { get; set; }  	internal _IMessageSink? InternalDiagnosticMessageSink { get; set; }  	/// <summary> 	/// Gets the current test pipeline stage. 	/// </summary> 	public TestPipelineStage PipelineStage { get; private set; }  	/// <summary> 	/// Gets the current test, if the engine is currently in the process of running a test; 	/// will return <c>null</c> outside of the context of a test. 	/// </summary> 	public _ITest? Test { get; private set; }  	/// <summary> 	/// Gets the current test assembly, if the engine is currently in the process of running or 	/// discovering tests in assembly; will return <c>null</c> out of this context (this typically 	/// means the test framework itself is being created and initialized). 	/// </summary> 	[NotNullIfNotNull(nameof(TestCollection))] 	public _ITestAssembly? TestAssembly { get; private set; }  	/// <summary> 	/// Gets the current test engine status for the test assembly. 	/// </summary> 	[NotNullIfNotNull(nameof(TestAssembly))] 	public TestEngineStatus? TestAssemblyStatus { get; private set; }  	/// <summary> 	/// Gets the current test case, if the engine is currently in the process of running a 	/// test case; will return <c>null</c> outside of the context of a test case. 	/// </summary> 	[NotNullIfNotNull(nameof(Test))] 	public _ITestCase? TestCase { get; private set; }  	/// <summary> 	/// Gets the current test engine status for the test case. Will only be available when <see cref=""TestCase""/> 	/// is not <c>null</c>. 	/// </summary> 	[NotNullIfNotNull(nameof(TestCase))] 	public TestEngineStatus? TestCaseStatus { get; private set; }  	/// <summary> 	/// Gets the current test method, if the engine is currently in the process of running 	/// a test class; will return <c>null</c> outside of the context of a test class. Note that 	/// not all test framework implementations require that tests be based on classes, so this 	/// value may be <c>null</c> even if <see cref=""TestCase""/> is not <c>null</c>. 	/// </summary> 	[NotNullIfNotNull(nameof(TestMethod))] 	public _ITestClass? TestClass { get; private set; }  	/// <summary> 	/// Gets the current test engine status for the test class. Will only be available when <see cref=""TestClass""/> 	/// is not <c>null</c>. 	/// </summary> 	[NotNullIfNotNull(nameof(TestClass))] 	public TestEngineStatus? TestClassStatus { get; private set; }  	/// <summary> 	/// Gets the current test collection, if the engine is currently in the process of running 	/// a test collection; will return <c>null</c> outside of the context of a test collection. 	/// </summary> 	[NotNullIfNotNull(nameof(TestClass))] 	[NotNullIfNotNull(nameof(TestCase))] 	public _ITestCollection? TestCollection { get; private set; }  	/// <summary> 	/// Gets the current test engine status for the test collection. Will only be available when 	/// <see cref=""TestCollection""/> is not <c>null</c>. 	/// </summary> 	[NotNullIfNotNull(nameof(TestCollection))] 	public TestEngineStatus? TestCollectionStatus { get; private set; }  	/// <summary> 	/// Gets the output helper, which can be used to add output to the test. Will only be 	/// available when <see cref=""Test""/> is not <c>null</c>. Note that the value may still 	/// be <c>null</c> when <see cref=""Test""/> is not <c>null</c>, if the test framework 	/// implementation does not provide output helper support. 	/// </summary> 	public _ITestOutputHelper? TestOutputHelper { get; private set; }  	/// <summary> 	/// Gets the current test method, if the engine is currently in the process of running 	/// a test method; will return <c>null</c> outside of the context of a test method. Note that 	/// not all test framework implementations require that tests be based on methods, so this 	/// value may be <c>null</c> even if <see cref=""TestCase""/> is not <c>null</c>. 	/// </summary> 	public _ITestMethod? TestMethod { get; private set; }  	/// <summary> 	/// Gets the current test engine status for the test method. Will only be available when <see cref=""TestMethod""/> 	/// is not <c>null</c>. 	/// </summary> 	[NotNullIfNotNull(nameof(TestMethod))] 	public TestEngineStatus? TestMethodStatus { get; private set; }  	/// <summary> 	/// Gets the current state of the test. Will only be available when <see cref=""TestStatus""/> 	/// is <see cref=""TestEngineStatus.CleaningUp""/>. 	/// </summary> 	public TestResultState? TestState { get; private set; }  	/// <summary> 	/// Gets the current test engine status for the test. Will only be available when <see cref=""Test""/> 	/// is not <c>null</c>. 	/// </summary> 	[NotNullIfNotNull(nameof(Test))] 	public TestEngineStatus? TestStatus { get; private set; }  	/// <summary> 	/// Gets the set of warnings associated with the current test. Will only be available when <see cref=""Test""/> 	/// is not <c>null</c>; will also return <c>null</c> if there have been no warnings issued. 	/// </summary> 	public IReadOnlyList<string>? Warnings => 		warnings?.Count > 0 ? warnings : null;  	/// <summary> 	/// Adds a warning to the test result. 	/// </summary> 	/// <param name=""message"">The warning message to be reported</param> 	public void AddWarning(string message) 	{ 		if (Test is null || warnings is null) 			SendDiagnosticMessage(""Attempted to log a test warning message while not running a test (pipeline stage = {0}); message: {1}"", PipelineStage, message); 		else 			warnings.Add(message); 	}  	/// <summary> 	/// Sends a diagnostic message. Will only be visible if the end user has enabled diagnostic messages. 	/// See https://xunit.net/docs/configuration-files for configuration information. 	/// </summary> 	/// <param name=""message"">The message to send</param> 	public void SendDiagnosticMessage(string message) 	{ 		if (DiagnosticMessageSink is not null) 			DiagnosticMessageSink.OnMessage(new _DiagnosticMessage { Message = message }); 	}  	/// <summary> 	/// Sends a formatted diagnostic message. Will only be visible if the end user has enabled diagnostic messages. 	/// See https://xunit.net/docs/configuration-files for configuration information. 	/// </summary> 	/// <param name=""format"">A composite format string.</param> 	/// <param name=""arg0"">The value to replace {0} in the format string.</param> 	public void SendDiagnosticMessage( 		string format, 		object? arg0) 	{ 		if (DiagnosticMessageSink is not null) 			DiagnosticMessageSink.OnMessage(new _DiagnosticMessage { Message = string.Format(CultureInfo.CurrentCulture, format, arg0) }); 	}  	/// <summary> 	/// Sends a formatted diagnostic message. Will only be visible if the end user has enabled diagnostic messages. 	/// See https://xunit.net/docs/configuration-files for configuration information. 	/// </summary> 	/// <param name=""format"">A composite format string.</param> 	/// <param name=""arg0"">The value to replace {0} in the format string.</param> 	/// <param name=""arg1"">The value to replace {1} in the format string.</param> 	public void SendDiagnosticMessage( 		string format, 		object? arg0, 		object? arg1) 	{ 		if (DiagnosticMessageSink is not null) 			DiagnosticMessageSink.OnMessage(new _DiagnosticMessage { Message = string.Format(CultureInfo.CurrentCulture, format, arg0, arg1) }); 	}  	/// <summary> 	/// Sends a formatted diagnostic message. Will only be visible if the end user has enabled diagnostic messages. 	/// See https://xunit.net/docs/configuration-files for configuration information. 	/// </summary> 	/// <param name=""format"">A composite format string.</param> 	/// <param name=""arg0"">The value to replace {0} in the format string.</param> 	/// <param name=""arg1"">The value to replace {1} in the format string.</param> 	/// <param name=""arg2"">The value to replace {2} in the format string.</param> 	public void SendDiagnosticMessage( 		string format, 		object? arg0, 		object? arg1, 		object? arg2) 	{ 		if (DiagnosticMessageSink is not null) 			DiagnosticMessageSink.OnMessage(new _DiagnosticMessage { Message = string.Format(CultureInfo.CurrentCulture, format, arg0, arg1, arg2) }); 	}  	/// <summary> 	/// Sends a formatted diagnostic message. Will only be visible if the end user has enabled diagnostic messages. 	/// See https://xunit.net/docs/configuration-files for configuration information. 	/// </summary> 	/// <param name=""format"">A composite format string.</param> 	/// <param name=""args"">An object array that contains zero or more objects to format.</param> 	public void SendDiagnosticMessage( 		string format, 		params object?[] args) 	{ 		if (DiagnosticMessageSink is not null) 			DiagnosticMessageSink.OnMessage(new _DiagnosticMessage { Message = string.Format(CultureInfo.CurrentCulture, format, args) }); 	}  	internal void SendInternalDiagnosticMessage(string message) 	{ 		if (InternalDiagnosticMessageSink is not null) 			InternalDiagnosticMessageSink.OnMessage(new _InternalDiagnosticMessage { Message = message }); 	}  	internal void SendInternalDiagnosticMessage( 		string format, 		object? arg0) 	{ 		if (InternalDiagnosticMessageSink is not null) 			InternalDiagnosticMessageSink.OnMessage(new _InternalDiagnosticMessage { Message = string.Format(CultureInfo.CurrentCulture, format, arg0) }); 	}  	internal void SendInternalDiagnosticMessage( 		string format, 		object? arg0, 		object? arg1) 	{ 		if (InternalDiagnosticMessageSink is not null) 			InternalDiagnosticMessageSink.OnMessage(new _InternalDiagnosticMessage { Message = string.Format(CultureInfo.CurrentCulture, format, arg0, arg1) }); 	}  	internal void SendInternalDiagnosticMessage( 		string format, 		object? arg0, 		object? arg1, 		object? arg2) 	{ 		if (InternalDiagnosticMessageSink is not null) 			InternalDiagnosticMessageSink.OnMessage(new _InternalDiagnosticMessage { Message = string.Format(CultureInfo.CurrentCulture, format, arg0, arg1, arg2) }); 	}  	internal void SendInternalDiagnosticMessage( 		string format, 		params object?[] args) 	{ 		if (InternalDiagnosticMessageSink is not null) 			InternalDiagnosticMessageSink.OnMessage(new _InternalDiagnosticMessage { Message = string.Format(CultureInfo.CurrentCulture, format, args) }); 	}  	/// <summary> 	/// Sets the test context for test framework initialization. This is the moment before any specific assembly is 	/// being discovered or run. This is typically used by custom runners just before they create the test framework 	/// via a call to <see cref=""ExtensibilityPointFactory.GetTestFramework""/>. 	/// </summary> 	/// <param name=""diagnosticMessageSink"">The optional message sink used to receive <see cref=""_DiagnosticMessage""/> 	/// and <see cref=""_InternalDiagnosticMessage""/> instances.</param> 	/// <param name=""diagnosticMessages"">A flag to indicate whether the user wants to receive diagnostic messages</param> 	/// <param name=""internalDiagnosticMessages"">A flag to indicate whether the user wants to receive internal diagnostic messages</param> 	public static void SetForInitialization( 		_IMessageSink? diagnosticMessageSink, 		bool diagnosticMessages, 		bool internalDiagnosticMessages) => 			local.Value = new TestContext(diagnosticMessages ? diagnosticMessageSink : null, internalDiagnosticMessages ? diagnosticMessageSink : null, TestPipelineStage.Initialization, default);  	/// <summary> 	/// Sets the test context for execution of a test. This assumes an existing test context already exists from which 	/// it can pull the diagnostic and internal diagnostic message sinks. 	/// </summary> 	/// <param name=""test"">The test that is being executed</param> 	/// <param name=""testStatus"">The test status (valid values: <see cref=""TestEngineStatus.Initializing""/>, 	/// <see cref=""TestEngineStatus.Running""/>, and <see cref=""TestEngineStatus.CleaningUp""/>)</param> 	/// <param name=""cancellationToken"">The cancellation token used to cancel execution</param> 	/// <param name=""testState"">The state of the test (only required when <paramref name=""testStatus""/> 	/// is <see cref=""TestEngineStatus.CleaningUp""/>).</param> 	/// <param name=""testOutputHelper"">The test output helper that the test can use to write output. Must be passed 	/// when <paramref name=""testStatus""/> is <see cref=""TestEngineStatus.Initializing""/>; can be <c>null</c> for 	/// other statuses (as it will be pulled from the existing test context).</param> 	public static void SetForTest( 		_ITest test, 		TestEngineStatus testStatus, 		CancellationToken cancellationToken, 		TestResultState? testState = null, 		_ITestOutputHelper? testOutputHelper = null) 	{ 		Guard.ArgumentNotNull(test); 		Guard.ArgumentEnumValid(testStatus, validExecutionStatuses); 		Guard.NotNull(""TestContext.Current must be non-null"", Current);  		if (testStatus == TestEngineStatus.CleaningUp) 			Guard.ArgumentNotNull(testState);  		if (Current.TestOutputHelper is null) 			Guard.ArgumentNotNull(testOutputHelper);  		local.Value = new TestContext(Current.DiagnosticMessageSink, Current.InternalDiagnosticMessageSink, TestPipelineStage.TestExecution, cancellationToken, Current.warnings ?? new()) 		{ 			Test = test, 			TestStatus = testStatus, 			TestOutputHelper = testOutputHelper ?? Current.TestOutputHelper, 			TestState = testState,  			TestCase = test.TestCase, 			TestCaseStatus = TestEngineStatus.Running,  			TestMethod = test.TestCase.TestMethod, 			TestMethodStatus = test.TestCase.TestMethod is null ? null : TestEngineStatus.Running,  			TestClass = test.TestCase.TestClass, 			TestClassStatus = test.TestCase.TestClass is null ? null : TestEngineStatus.Running,  			TestCollection = test.TestCase.TestCollection, 			TestCollectionStatus = TestEngineStatus.Running,  			TestAssembly = test.TestCase.TestCollection.TestAssembly, 			TestAssemblyStatus = TestEngineStatus.Running, 		}; 	}  	/// <summary> 	/// Sets the test context for discovery or execution of a test assembly. This assumes an existing test context already exists 	/// from which it can pull the diagnostic and internal diagnostic message sinks. 	/// </summary> 	/// <param name=""testAssembly"">The test assembly that is being executed</param> 	/// <param name=""testAssemblyStatus"">The test assembly status</param> 	/// <param name=""cancellationToken"">The cancellation token used to cancel execution</param> 	public static void SetForTestAssembly( 		_ITestAssembly testAssembly, 		TestEngineStatus testAssemblyStatus, 		CancellationToken cancellationToken) 	{ 		Guard.ArgumentNotNull(testAssembly); 		Guard.NotNull(""TestContext.Current must be non-null"", Current);  		var pipelineStage = 			testAssemblyStatus == TestEngineStatus.Discovering 				? TestPipelineStage.Discovery 				: TestPipelineStage.TestAssemblyExecution;  		local.Value = new TestContext(Current.DiagnosticMessageSink, Current.InternalDiagnosticMessageSink, pipelineStage, cancellationToken) 		{ 			TestAssembly = testAssembly, 			TestAssemblyStatus = testAssemblyStatus, 		}; 	}  	/// <summary> 	/// Sets the test context for execution of a test case. This assumes an existing test context already exists from which 	/// it can pull the diagnostic and internal diagnostic message sinks. 	/// </summary> 	/// <param name=""testCase"">The test case that is being executed</param> 	/// <param name=""testCaseStatus"">The test case status (valid values: <see cref=""TestEngineStatus.Initializing""/>, 	/// <see cref=""TestEngineStatus.Running""/>, and <see cref=""TestEngineStatus.CleaningUp""/>)</param> 	/// <param name=""cancellationToken"">The cancellation token used to cancel execution</param> 	public static void SetForTestCase( 		_ITestCase testCase, 		TestEngineStatus testCaseStatus, 		CancellationToken cancellationToken) 	{ 		Guard.ArgumentNotNull(testCase); 		Guard.ArgumentEnumValid(testCaseStatus, validExecutionStatuses); 		Guard.NotNull(""TestContext.Current must be non-null"", Current);  		local.Value = new TestContext(Current.DiagnosticMessageSink, Current.InternalDiagnosticMessageSink, TestPipelineStage.TestCaseExecution, cancellationToken) 		{ 			TestCase = testCase, 			TestCaseStatus = testCaseStatus,  			TestMethod = testCase.TestMethod, 			TestMethodStatus = testCase.TestMethod is null ? null : TestEngineStatus.Running,  			TestClass = testCase.TestClass, 			TestClassStatus = testCase.TestClass is null ? null : TestEngineStatus.Running,  			TestCollection = testCase.TestCollection, 			TestCollectionStatus = TestEngineStatus.Running,  			TestAssembly = testCase.TestCollection.TestAssembly, 			TestAssemblyStatus = TestEngineStatus.Running, 		}; 	}  	/// <summary> 	/// Sets the test context for execution of a test class. This assumes an existing test context already exists from which 	/// it can pull the diagnostic and internal diagnostic message sinks. 	/// </summary> 	/// <param name=""testClass"">The test class that is being executed</param> 	/// <param name=""testClassStatus"">The test class status (valid values: <see cref=""TestEngineStatus.Initializing""/>, 	/// <see cref=""TestEngineStatus.Running""/>, and <see cref=""TestEngineStatus.CleaningUp""/>)</param> 	/// <param name=""cancellationToken"">The cancellation token used to cancel execution</param> 	public static void SetForTestClass( 		_ITestClass testClass, 		TestEngineStatus testClassStatus, 		CancellationToken cancellationToken) 	{ 		Guard.ArgumentNotNull(testClass); 		Guard.ArgumentEnumValid(testClassStatus, validExecutionStatuses); 		Guard.NotNull(""TestContext.Current must be non-null"", Current);  		local.Value = new TestContext(Current.DiagnosticMessageSink, Current.InternalDiagnosticMessageSink, TestPipelineStage.TestClassExecution, cancellationToken) 		{ 			TestClass = testClass, 			TestClassStatus = testClassStatus,  			TestCollection = testClass.TestCollection, 			TestCollectionStatus = TestEngineStatus.Running,  			TestAssembly = testClass.TestCollection.TestAssembly, 			TestAssemblyStatus = TestEngineStatus.Running, 		}; 	}  	/// <summary> 	/// Sets the test context for execution of a test collection. This assumes an existing test context already exists from which 	/// it can pull the diagnostic and internal diagnostic message sinks. 	/// </summary> 	/// <param name=""testCollection"">The test collection that is being executed</param> 	/// <param name=""testCollectionStatus"">The test collection status (valid values: <see cref=""TestEngineStatus.Initializing""/>, 	/// <see cref=""TestEngineStatus.Running""/>, and <see cref=""TestEngineStatus.CleaningUp""/>)</param> 	/// <param name=""cancellationToken"">The cancellation token used to cancel execution</param> 	public static void SetForTestCollection( 		_ITestCollection testCollection, 		TestEngineStatus testCollectionStatus, 		CancellationToken cancellationToken) 	{ 		Guard.ArgumentNotNull(testCollection); 		Guard.ArgumentEnumValid(testCollectionStatus, validExecutionStatuses); 		Guard.NotNull(""TestContext.Current must be non-null"", Current);  		local.Value = new TestContext(Current.DiagnosticMessageSink, Current.InternalDiagnosticMessageSink, TestPipelineStage.TestCollectionExecution, cancellationToken) 		{ 			TestCollection = testCollection, 			TestCollectionStatus = testCollectionStatus,  			TestAssembly = testCollection.TestAssembly, 			TestAssemblyStatus = TestEngineStatus.Running, 		}; 	}  	/// <summary> 	/// Sets the test context for execution of a test method. This assumes an existing test context already exists from which 	/// it can pull the diagnostic and internal diagnostic message sinks. 	/// </summary> 	/// <param name=""testMethod"">The test method that is being executed</param> 	/// <param name=""testMethodStatus"">The test method status (valid values: <see cref=""TestEngineStatus.Initializing""/>, 	/// <see cref=""TestEngineStatus.Running""/>, and <see cref=""TestEngineStatus.CleaningUp""/>)</param> 	/// <param name=""cancellationToken"">The cancellation token used to cancel execution</param> 	public static void SetForTestMethod( 		_ITestMethod testMethod, 		TestEngineStatus testMethodStatus, 		CancellationToken cancellationToken) 	{ 		Guard.ArgumentNotNull(testMethod); 		Guard.ArgumentEnumValid(testMethodStatus, validExecutionStatuses); 		Guard.NotNull(""TestContext.Current must be non-null"", Current);  		local.Value = new TestContext(Current.DiagnosticMessageSink, Current.InternalDiagnosticMessageSink, TestPipelineStage.TestMethodExecution, cancellationToken) 		{ 			TestMethod = testMethod, 			TestMethodStatus = testMethodStatus,  			TestClass = testMethod.TestClass, 			TestClassStatus = TestEngineStatus.Running,  			TestCollection = testMethod.TestClass.TestCollection, 			TestCollectionStatus = TestEngineStatus.Running,  			TestAssembly = testMethod.TestClass.TestCollection.TestAssembly, 			TestAssemblyStatus = TestEngineStatus.Running, 		}; 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\TestEngineStatus.cs,"namespace Xunit;  /// <summary> /// Represents the current status of the execution of the test engine, with respect to /// a phase in the execution pipeline (for example, engine status for a test collection vs. /// test case vs. test). /// </summary> public enum TestEngineStatus { 	/// <summary> 	/// The test engine is in the initialization phase of the given stage in the pipeline. 	/// </summary> 	Initializing = 1,  	/// <summary> 	/// The test engine is running the given state of the pipeline. 	/// </summary> 	Running,  	/// <summary> 	/// The test engine has run the given stage of the pipeline, and is currently doing clean up (f.e., Dispose). 	/// </summary> 	CleaningUp,  	/// <summary> 	/// The test engine is in the process of discovering tests. 	/// </summary> 	Discovering, }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\TestFrameworkAttribute.cs,"#pragma warning disable CA1019 // The attribute arguments are always read via reflection  using System; using Xunit.Sdk; using Xunit.v3;  namespace Xunit;  /// <summary> /// Used to decorate an assembly to allow the use of a custom <see cref=""_ITestFramework""/>. /// </summary> [TestFrameworkDiscoverer(typeof(TestFrameworkTypeDiscoverer))] [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)] public sealed class TestFrameworkAttribute : Attribute, ITestFrameworkAttribute { 	/// <summary> 	/// Initializes an instance of <see cref=""TestFrameworkAttribute""/>. 	/// </summary> 	/// <param name=""typeName"">The fully qualified type name of the test framework 	/// (f.e., 'Xunit.Sdk.XunitTestFramework')</param> 	/// <param name=""assemblyName"">The name of the assembly that the test framework type 	/// is located in, without file extension (f.e., 'xunit.v3.core')</param> 	public TestFrameworkAttribute( 		string typeName, 		string assemblyName) 	{ }  	/// <summary> 	/// Initializes an instance of <see cref=""TestFrameworkAttribute""/>. 	/// </summary> 	/// <param name=""frameworkType"">The framework type</param> 	public TestFrameworkAttribute(Type frameworkType) 	{ } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\TestPipelineStage.cs,"namespace Xunit;  /// <summary> /// A flag to indicate which part of the test pipeline you're in. Retrieved from an /// instance of <see cref=""TestContext""/>. /// </summary> public enum TestPipelineStage { 	/// <summary> 	/// Indicates an unknown state of the test pipeline, or being outside of the test pipeline. 	/// </summary> 	Unknown,  	/// <summary> 	/// Indicates that the test pipeline is still in the initialization phase and hasn't begun work. 	/// </summary> 	Initialization,  	/// <summary> 	/// Indicates that tests are currently being discovered. 	/// </summary> 	Discovery,  	/// <summary> 	/// Inidicates that the test pipeline is executing a test assembly. 	/// </summary> 	TestAssemblyExecution,  	/// <summary> 	/// Inidicates that the test pipeline is executing a test collection. 	/// </summary> 	TestCollectionExecution,  	/// <summary> 	/// Inidicates that the test pipeline is executing a test class. 	/// </summary> 	TestClassExecution,  	/// <summary> 	/// Inidicates that the test pipeline is executing a test method. 	/// </summary> 	TestMethodExecution,  	/// <summary> 	/// Inidicates that the test pipeline is executing a test case. 	/// </summary> 	TestCaseExecution,  	/// <summary> 	/// Inidicates that the test pipeline is executing a test. 	/// </summary> 	TestExecution, }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\TestResult.cs,"namespace Xunit;  /// <summary> /// Indicates the result of running the test. /// </summary> public enum TestResult { 	/// <summary> 	/// The test passed. 	/// </summary> 	Passed,  	/// <summary> 	/// The test failed. 	/// </summary> 	Failed,  	/// <summary> 	/// The test was skipped. 	/// </summary> 	Skipped,  	/// <summary> 	/// The test was not run because it was excluded (either because it was marked as explicit 	/// and explicit tests weren't run, or because it was marked as not explicit as only explicit 	/// tests were run). 	/// </summary> 	NotRun, }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\TestResultState.cs,"using System; using System.Globalization; using Xunit.Internal; using Xunit.Sdk; using Xunit.v3;  namespace Xunit;  /// <summary> /// Represents information about the current state of a test after it has run. /// </summary> public class TestResultState { 	TestResultState() 	{ }  	/// <summary> 	/// Gets the message(s) of the exception(s). This value is only available 	/// when <see cref=""Result""/> is <see cref=""TestResult.Failed""/>. 	/// </summary> 	public string[]? ExceptionMessages { get; private set; }  	/// <summary> 	/// Gets the parent exception index(es) for the exception(s); a -1 indicates 	/// that the exception in question has no parent. This value is only available 	/// when <see cref=""Result""/> is <see cref=""TestResult.Failed""/>. 	/// </summary> 	public int[]? ExceptionParentIndices { get; private set; }  	/// <summary> 	/// Gets the stack trace(s) of the exception(s). This value is only available 	/// when <see cref=""Result""/> is <see cref=""TestResult.Failed""/>. 	/// </summary> 	public string?[]? ExceptionStackTraces { get; private set; }  	/// <summary> 	/// Gets the fully-qualified type name(s) of the exception(s). This value is 	/// only available when <see cref=""Result""/> is <see cref=""TestResult.Failed""/>. 	/// </summary> 	public string?[]? ExceptionTypes { get; private set; }  	/// <summary> 	/// Gets the amount of time the test ran, in seconds. The value may be <c>0</c> if no 	/// test code was run (for example, a statically skipped test). Note that the value may 	/// be a partial value because of further timing being done while cleaning up. 	/// </summary> 	public decimal? ExecutionTime { get; private set; }  	/// <summary> 	/// Gets a value which indicates what the cause of the test failure was. This value is only 	/// available when <see cref=""Result""/> is <see cref=""TestResult.Failed""/>. 	/// </summary> 	public FailureCause? FailureCause { get; private set; }  	/// <summary> 	/// Returns the result from the test run. 	/// </summary> 	public TestResult Result { get; private set; }  	/// <summary> 	/// Gets an immutable instance to indicates a test has a result. 	/// </summary> 	/// <param name=""executionTime"">The time spent executing the test</param> 	/// <param name=""exception"">The exception, if the test failed</param> 	public static TestResultState FromException( 		decimal executionTime, 		Exception? exception) 	{ 		var result = new TestResultState { ExecutionTime = executionTime };  		if (exception is null) 			result.Result = TestResult.Passed; 		else 		{ 			var errorMetadata = ExceptionUtility.ExtractMetadata(exception);  			result.ExceptionMessages = errorMetadata.Messages; 			result.ExceptionParentIndices = errorMetadata.ExceptionParentIndices; 			result.ExceptionStackTraces = errorMetadata.StackTraces; 			result.ExceptionTypes = errorMetadata.ExceptionTypes; 			result.FailureCause = errorMetadata.Cause; 			result.Result = TestResult.Failed; 		}  		return result; 	}  	/// <summary/> 	public static TestResultState FromTestResult(_TestResultMessage testResult) 	{ 		Guard.ArgumentNotNull(testResult);  		var result = new TestResultState { ExecutionTime = testResult.ExecutionTime };  		if (testResult is _TestPassed) 			result.Result = TestResult.Passed; 		else if (testResult is _TestSkipped) 			result.Result = TestResult.Skipped; 		else if (testResult is _TestNotRun) 			result.Result = TestResult.NotRun; 		else if (testResult is _TestFailed testFailed) 		{ 			result.ExceptionMessages = testFailed.Messages; 			result.ExceptionParentIndices = testFailed.ExceptionParentIndices; 			result.ExceptionStackTraces = testFailed.StackTraces; 			result.ExceptionTypes = testFailed.ExceptionTypes; 			result.FailureCause = testFailed.Cause; 			result.Result = TestResult.Failed; 		} 		else 			throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, ""Unknown type: '{0}'"", testResult.GetType().FullName), nameof(testResult));  		return result; 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\TheoryAttribute.cs,"#pragma warning disable CA1813 // This attribute is unsealed because it's an extensibility point  using System; using Xunit.Sdk;  namespace Xunit;  /// <summary> /// Marks a test method as being a data theory. Data theories are tests which are fed /// various bits of data from a data source, mapping to parameters on the test method. /// If the data source contains multiple rows, then the test method is executed /// multiple times (once with each data row). Data is provided by attributes which /// derive from <see cref=""DataAttribute""/> (notably, <see cref=""InlineDataAttribute""/> and /// <see cref=""MemberDataAttribute""/>). /// </summary> [XunitTestCaseDiscoverer(typeof(TheoryDiscoverer))] [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class TheoryAttribute : FactAttribute { 	/// <summary> 	/// Returns <c>true</c> if the data attribute wants to skip enumerating data during discovery. 	/// This will cause the theory to yield a single test case for all data, and the data discovery 	/// will be during test execution instead of discovery. 	/// </summary> 	public bool DisableDiscoveryEnumeration { get; set; } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\TheoryData.cs,"using System.Collections; using System.Collections.Generic; using System.Linq; using Xunit.Internal;  namespace Xunit;  /// <summary> /// Provides data for theories based on collection initialization syntax. /// </summary> public abstract class TheoryData : IReadOnlyCollection<object?[]> { 	readonly List<object?[]> data = new();  	/// <inheritdoc/> 	public int Count => data.Count;  	/// <summary> 	/// Adds a row to the theory. 	/// </summary> 	/// <param name=""values"">The values to be added.</param> 	protected void AddRow(params object?[] values) 	{ 		Guard.ArgumentNotNull(values);  		data.Add(values); 	}  	/// <summary> 	/// Adds multiple rows to the theory. 	/// </summary> 	/// <param name=""rows"">The rows to be added.</param> 	protected void AddRows(IEnumerable<object?[]> rows) 	{ 		Guard.ArgumentNotNull(rows);  		foreach (var row in rows) 			AddRow(row); 	}  	/// <inheritdoc/> 	public IEnumerator<object?[]> GetEnumerator() => data.GetEnumerator();  	/// <inheritdoc/> 	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator(); }  /// <summary> /// Represents a set of data for a theory with a single parameter. Data can /// be added to the data set using the collection initializer syntax. /// </summary> /// <typeparam name=""T"">The parameter type.</typeparam> public class TheoryData<T> : TheoryData { 	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(IEnumerable<T> values) 	{ 		Guard.ArgumentNotNull(values);  		AddRange(values.ToArray()); 	}  	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(params T[] values) => 		AddRange(values);  	/// <summary> 	/// Adds data to the theory data set. 	/// </summary> 	/// <param name=""p"">The data value.</param> 	public void Add(T p) => 		AddRow(p);  	/// <summary> 	/// Adds multiple data items to the theory data set. 	/// </summary> 	/// <param name=""values"">The data values.</param> 	public void AddRange(params T[] values) => 		AddRows(values.Select(x => new object?[] { x })); }  /// <summary> /// Represents a set of data for a theory with 2 parameters. Data can /// be added to the data set using the collection initializer syntax. /// </summary> /// <typeparam name=""T1"">The first parameter type.</typeparam> /// <typeparam name=""T2"">The second parameter type.</typeparam> public class TheoryData<T1, T2> : TheoryData { 	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(IEnumerable<(T1, T2)> values) 	{ 		Guard.ArgumentNotNull(values);  		AddRange(values.ToArray()); 	}  	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(params (T1, T2)[] values) => 		AddRange(values);  	/// <summary> 	/// Adds data to the theory data set. 	/// </summary> 	/// <param name=""p1"">The first data value.</param> 	/// <param name=""p2"">The second data value.</param> 	public void Add(T1 p1, T2 p2) => 		AddRow(p1, p2);  	/// <summary> 	/// Adds multiple data items to the theory data set. 	/// </summary> 	/// <param name=""values"">The data values.</param> 	public void AddRange(params (T1 p1, T2 p2)[] values) 	{ 		Guard.ArgumentNotNull(values);  		AddRows(values.Select(x => new object?[] { x.p1, x.p2 })); 	} }  /// <summary> /// Represents a set of data for a theory with 3 parameters. Data can /// be added to the data set using the collection initializer syntax. /// </summary> /// <typeparam name=""T1"">The first parameter type.</typeparam> /// <typeparam name=""T2"">The second parameter type.</typeparam> /// <typeparam name=""T3"">The third parameter type.</typeparam> public class TheoryData<T1, T2, T3> : TheoryData { 	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(IEnumerable<(T1, T2, T3)> values) 	{ 		Guard.ArgumentNotNull(values);  		AddRange(values.ToArray()); 	}  	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(params (T1, T2, T3)[] values) => 		AddRange(values);  	/// <summary> 	/// Adds data to the theory data set. 	/// </summary> 	/// <param name=""p1"">The first data value.</param> 	/// <param name=""p2"">The second data value.</param> 	/// <param name=""p3"">The third data value.</param> 	public void Add(T1 p1, T2 p2, T3 p3) => 		AddRow(p1, p2, p3);  	/// <summary> 	/// Adds multiple data items to the theory data set. 	/// </summary> 	/// <param name=""values"">The data values.</param> 	public void AddRange(params (T1 p1, T2 p2, T3 p3)[] values) 	{ 		Guard.ArgumentNotNull(values);  		AddRows(values.Select(x => new object?[] { x.p1, x.p2, x.p3 })); 	} }  /// <summary> /// Represents a set of data for a theory with 4 parameters. Data can /// be added to the data set using the collection initializer syntax. /// </summary> /// <typeparam name=""T1"">The first parameter type.</typeparam> /// <typeparam name=""T2"">The second parameter type.</typeparam> /// <typeparam name=""T3"">The third parameter type.</typeparam> /// <typeparam name=""T4"">The fourth parameter type.</typeparam> public class TheoryData<T1, T2, T3, T4> : TheoryData { 	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(IEnumerable<(T1, T2, T3, T4)> values) 	{ 		Guard.ArgumentNotNull(values);  		AddRange(values.ToArray()); 	}  	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(params (T1, T2, T3, T4)[] values) => 		AddRange(values);  	/// <summary> 	/// Adds data to the theory data set. 	/// </summary> 	/// <param name=""p1"">The first data value.</param> 	/// <param name=""p2"">The second data value.</param> 	/// <param name=""p3"">The third data value.</param> 	/// <param name=""p4"">The fourth data value.</param> 	public void Add(T1 p1, T2 p2, T3 p3, T4 p4) => 		AddRow(p1, p2, p3, p4);  	/// <summary> 	/// Adds multiple data items to the theory data set. 	/// </summary> 	/// <param name=""values"">The data values.</param> 	public void AddRange(params (T1 p1, T2 p2, T3 p3, T4 p4)[] values) 	{ 		Guard.ArgumentNotNull(values);  		AddRows(values.Select(x => new object?[] { x.p1, x.p2, x.p3, x.p4 })); 	} }  /// <summary> /// Represents a set of data for a theory with 5 parameters. Data can /// be added to the data set using the collection initializer syntax. /// </summary> /// <typeparam name=""T1"">The first parameter type.</typeparam> /// <typeparam name=""T2"">The second parameter type.</typeparam> /// <typeparam name=""T3"">The third parameter type.</typeparam> /// <typeparam name=""T4"">The fourth parameter type.</typeparam> /// <typeparam name=""T5"">The fifth parameter type.</typeparam> public class TheoryData<T1, T2, T3, T4, T5> : TheoryData { 	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(IEnumerable<(T1, T2, T3, T4, T5)> values) 	{ 		Guard.ArgumentNotNull(values);  		AddRange(values.ToArray()); 	}  	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(params (T1, T2, T3, T4, T5)[] values) => 		AddRange(values);  	/// <summary> 	/// Adds data to the theory data set. 	/// </summary> 	/// <param name=""p1"">The first data value.</param> 	/// <param name=""p2"">The second data value.</param> 	/// <param name=""p3"">The third data value.</param> 	/// <param name=""p4"">The fourth data value.</param> 	/// <param name=""p5"">The fifth data value.</param> 	public void Add(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) => 		AddRow(p1, p2, p3, p4, p5);  	/// <summary> 	/// Adds multiple data items to the theory data set. 	/// </summary> 	/// <param name=""values"">The data values.</param> 	public void AddRange(params (T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)[] values) 	{ 		Guard.ArgumentNotNull(values);  		AddRows(values.Select(x => new object?[] { x.p1, x.p2, x.p3, x.p4, x.p5 })); 	} }  /// <summary> /// Represents a set of data for a theory with 6 parameters. Data can /// be added to the data set using the collection initializer syntax. /// </summary> /// <typeparam name=""T1"">The first parameter type.</typeparam> /// <typeparam name=""T2"">The second parameter type.</typeparam> /// <typeparam name=""T3"">The third parameter type.</typeparam> /// <typeparam name=""T4"">The fourth parameter type.</typeparam> /// <typeparam name=""T5"">The fifth parameter type.</typeparam> /// <typeparam name=""T6"">The sixth parameter type.</typeparam> public class TheoryData<T1, T2, T3, T4, T5, T6> : TheoryData { 	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5, T6}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(IEnumerable<(T1, T2, T3, T4, T5, T6)> values) 	{ 		Guard.ArgumentNotNull(values);  		AddRange(values.ToArray()); 	}  	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5, T6}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(params (T1, T2, T3, T4, T5, T6)[] values) => 		AddRange(values);  	/// <summary> 	/// Adds data to the theory data set. 	/// </summary> 	/// <param name=""p1"">The first data value.</param> 	/// <param name=""p2"">The second data value.</param> 	/// <param name=""p3"">The third data value.</param> 	/// <param name=""p4"">The fourth data value.</param> 	/// <param name=""p5"">The fifth data value.</param> 	/// <param name=""p6"">The sixth data value.</param> 	public void Add(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) => 		AddRow(p1, p2, p3, p4, p5, p6);  	/// <summary> 	/// Adds multiple data items to the theory data set. 	/// </summary> 	/// <param name=""values"">The data values.</param> 	public void AddRange(params (T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)[] values) 	{ 		Guard.ArgumentNotNull(values);  		AddRows(values.Select(x => new object?[] { x.p1, x.p2, x.p3, x.p4, x.p5, x.p6 })); 	} }  /// <summary> /// Represents a set of data for a theory with 7 parameters. Data can /// be added to the data set using the collection initializer syntax. /// </summary> /// <typeparam name=""T1"">The first parameter type.</typeparam> /// <typeparam name=""T2"">The second parameter type.</typeparam> /// <typeparam name=""T3"">The third parameter type.</typeparam> /// <typeparam name=""T4"">The fourth parameter type.</typeparam> /// <typeparam name=""T5"">The fifth parameter type.</typeparam> /// <typeparam name=""T6"">The sixth parameter type.</typeparam> /// <typeparam name=""T7"">The seventh parameter type.</typeparam> public class TheoryData<T1, T2, T3, T4, T5, T6, T7> : TheoryData { 	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5, T6, T7}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(IEnumerable<(T1, T2, T3, T4, T5, T6, T7)> values) 	{ 		Guard.ArgumentNotNull(values);  		AddRange(values.ToArray()); 	}  	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5, T6, T7}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(params (T1, T2, T3, T4, T5, T6, T7)[] values) => 		AddRange(values);  	/// <summary> 	/// Adds data to the theory data set. 	/// </summary> 	/// <param name=""p1"">The first data value.</param> 	/// <param name=""p2"">The second data value.</param> 	/// <param name=""p3"">The third data value.</param> 	/// <param name=""p4"">The fourth data value.</param> 	/// <param name=""p5"">The fifth data value.</param> 	/// <param name=""p6"">The sixth data value.</param> 	/// <param name=""p7"">The seventh data value.</param> 	public void Add(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) => 		AddRow(p1, p2, p3, p4, p5, p6, p7);  	/// <summary> 	/// Adds multiple data items to the theory data set. 	/// </summary> 	/// <param name=""values"">The data values.</param> 	public void AddRange(params (T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)[] values) 	{ 		Guard.ArgumentNotNull(values);  		AddRows(values.Select(x => new object?[] { x.p1, x.p2, x.p3, x.p4, x.p5, x.p6, x.p7 })); 	} }  /// <summary> /// Represents a set of data for a theory with 8 parameters. Data can /// be added to the data set using the collection initializer syntax. /// </summary> /// <typeparam name=""T1"">The first parameter type.</typeparam> /// <typeparam name=""T2"">The second parameter type.</typeparam> /// <typeparam name=""T3"">The third parameter type.</typeparam> /// <typeparam name=""T4"">The fourth parameter type.</typeparam> /// <typeparam name=""T5"">The fifth parameter type.</typeparam> /// <typeparam name=""T6"">The sixth parameter type.</typeparam> /// <typeparam name=""T7"">The seventh parameter type.</typeparam> /// <typeparam name=""T8"">The eighth parameter type.</typeparam> public class TheoryData<T1, T2, T3, T4, T5, T6, T7, T8> : TheoryData { 	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5, T6, T7, T8}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(IEnumerable<(T1, T2, T3, T4, T5, T6, T7, T8)> values) 	{ 		Guard.ArgumentNotNull(values);  		AddRange(values.ToArray()); 	}  	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5, T6, T7, T8}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(params (T1, T2, T3, T4, T5, T6, T7, T8)[] values) => 		AddRange(values);  	/// <summary> 	/// Adds data to the theory data set. 	/// </summary> 	/// <param name=""p1"">The first data value.</param> 	/// <param name=""p2"">The second data value.</param> 	/// <param name=""p3"">The third data value.</param> 	/// <param name=""p4"">The fourth data value.</param> 	/// <param name=""p5"">The fifth data value.</param> 	/// <param name=""p6"">The sixth data value.</param> 	/// <param name=""p7"">The seventh data value.</param> 	/// <param name=""p8"">The eighth data value.</param> 	public void Add(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) => 		AddRow(p1, p2, p3, p4, p5, p6, p7, p8);  	/// <summary> 	/// Adds multiple data items to the theory data set. 	/// </summary> 	/// <param name=""values"">The data values.</param> 	public void AddRange(params (T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)[] values) 	{ 		Guard.ArgumentNotNull(values);  		AddRows(values.Select(x => new object?[] { x.p1, x.p2, x.p3, x.p4, x.p5, x.p6, x.p7, x.p8 })); 	} }  /// <summary> /// Represents a set of data for a theory with 9 parameters. Data can /// be added to the data set using the collection initializer syntax. /// </summary> /// <typeparam name=""T1"">The first parameter type.</typeparam> /// <typeparam name=""T2"">The second parameter type.</typeparam> /// <typeparam name=""T3"">The third parameter type.</typeparam> /// <typeparam name=""T4"">The fourth parameter type.</typeparam> /// <typeparam name=""T5"">The fifth parameter type.</typeparam> /// <typeparam name=""T6"">The sixth parameter type.</typeparam> /// <typeparam name=""T7"">The seventh parameter type.</typeparam> /// <typeparam name=""T8"">The eighth parameter type.</typeparam> /// <typeparam name=""T9"">The ninth parameter type.</typeparam> public class TheoryData<T1, T2, T3, T4, T5, T6, T7, T8, T9> : TheoryData { 	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5, T6, T7, T8, T9}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(IEnumerable<(T1, T2, T3, T4, T5, T6, T7, T8, T9)> values) 	{ 		Guard.ArgumentNotNull(values);  		AddRange(values.ToArray()); 	}  	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5, T6, T7, T8, T9}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(params (T1, T2, T3, T4, T5, T6, T7, T8, T9)[] values) => 		AddRange(values);  	/// <summary> 	/// Adds data to the theory data set. 	/// </summary> 	/// <param name=""p1"">The first data value.</param> 	/// <param name=""p2"">The second data value.</param> 	/// <param name=""p3"">The third data value.</param> 	/// <param name=""p4"">The fourth data value.</param> 	/// <param name=""p5"">The fifth data value.</param> 	/// <param name=""p6"">The sixth data value.</param> 	/// <param name=""p7"">The seventh data value.</param> 	/// <param name=""p8"">The eighth data value.</param> 	/// <param name=""p9"">The ninth data value.</param> 	public void Add(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) => 		AddRow(p1, p2, p3, p4, p5, p6, p7, p8, p9);  	/// <summary> 	/// Adds multiple data items to the theory data set. 	/// </summary> 	/// <param name=""values"">The data values.</param> 	public void AddRange(params (T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9)[] values) 	{ 		Guard.ArgumentNotNull(values);  		AddRows(values.Select(x => new object?[] { x.p1, x.p2, x.p3, x.p4, x.p5, x.p6, x.p7, x.p8, x.p9 })); 	} }  /// <summary> /// Represents a set of data for a theory with 10 parameters. Data can /// be added to the data set using the collection initializer syntax. /// </summary> /// <typeparam name=""T1"">The first parameter type.</typeparam> /// <typeparam name=""T2"">The second parameter type.</typeparam> /// <typeparam name=""T3"">The third parameter type.</typeparam> /// <typeparam name=""T4"">The fourth parameter type.</typeparam> /// <typeparam name=""T5"">The fifth parameter type.</typeparam> /// <typeparam name=""T6"">The sixth parameter type.</typeparam> /// <typeparam name=""T7"">The seventh parameter type.</typeparam> /// <typeparam name=""T8"">The eighth parameter type.</typeparam> /// <typeparam name=""T9"">The ninth parameter type.</typeparam> /// <typeparam name=""T10"">The tenth parameter type.</typeparam> public class TheoryData<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> : TheoryData { 	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(IEnumerable<(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> values) 	{ 		Guard.ArgumentNotNull(values);  		AddRange(values.ToArray()); 	}  	/// <summary> 	/// Initializes a new isntance of the <see cref=""TheoryData{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}""/> class. 	/// </summary> 	/// <param name=""values"">The initial set of values</param> 	public TheoryData(params (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)[] values) => 		AddRange(values);  	/// <summary> 	/// Adds data to the theory data set. 	/// </summary> 	/// <param name=""p1"">The first data value.</param> 	/// <param name=""p2"">The second data value.</param> 	/// <param name=""p3"">The third data value.</param> 	/// <param name=""p4"">The fourth data value.</param> 	/// <param name=""p5"">The fifth data value.</param> 	/// <param name=""p6"">The sixth data value.</param> 	/// <param name=""p7"">The seventh data value.</param> 	/// <param name=""p8"">The eighth data value.</param> 	/// <param name=""p9"">The ninth data value.</param> 	/// <param name=""p10"">The tenth data value.</param> 	public void Add(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) => 		AddRow(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);  	/// <summary> 	/// Adds multiple data items to the theory data set. 	/// </summary> 	/// <param name=""values"">The data values.</param> 	public void AddRange(params (T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10)[] values) 	{ 		Guard.ArgumentNotNull(values);  		AddRows(values.Select(x => new object?[] { x.p1, x.p2, x.p3, x.p4, x.p5, x.p6, x.p7, x.p8, x.p9, x.p10 })); 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core\TraitAttribute.cs,"#pragma warning disable CA1019 // The attribute arguments are always read via reflection  using System; using Xunit.Sdk;  namespace Xunit;  /// <summary> /// Attribute used to decorate a test method, test class, or assembly with arbitrary name/value pairs (""traits""). /// </summary> [TraitDiscoverer(typeof(TraitDiscoverer))] [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class | AttributeTargets.Assembly, AllowMultiple = true)] public sealed class TraitAttribute : Attribute, ITraitAttribute { 	/// <summary> 	/// Creates a new instance of the <see cref=""TraitAttribute""/> class. 	/// </summary> 	/// <param name=""name"">The trait name</param> 	/// <param name=""value"">The trait value</param> 	public TraitAttribute( 		string name, 		string value) 	{ } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core.tests\MatrixTheoryDataTests.cs,"using System; using System.Linq; using System.Threading.Tasks; using Xunit; using Xunit.v3;  public class MatrixTheoryDataTests : AcceptanceTestV3 { 	[Fact] 	public void GuardClauses() 	{ 		var nonEmptyData = new[] { new object() };  		Assert.Throws<ArgumentNullException>(""dimension1"", () => new MatrixTheoryData<object?, object?>(null!, nonEmptyData)); 		Assert.Throws<ArgumentNullException>(""dimension2"", () => new MatrixTheoryData<object?, object?>(nonEmptyData, null!));  		var emptyData = Array.Empty<object>();  		Assert.Throws<ArgumentException>(""dimension1"", () => new MatrixTheoryData<object?, object?>(emptyData, nonEmptyData)); 		Assert.Throws<ArgumentException>(""dimension2"", () => new MatrixTheoryData<object?, object?>(nonEmptyData, emptyData)); 	}  	[Fact] 	public async ValueTask InvokesTestsForDataMatrix() 	{ 		var messages = await RunAsync(typeof(SampleUsage));  		Assert.Collection( 			messages.OfType<_TestPassed>().Select(passed => messages.OfType<_TestStarting>().Single(ts => ts.TestUniqueID == passed.TestUniqueID).TestDisplayName).OrderBy(x => x), 			displayName => Assert.Equal(""MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \""Hello\"", y: 5)"", displayName), 			displayName => Assert.Equal(""MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \""world!\"", y: 6)"", displayName) 		); 		Assert.Collection( 			messages.OfType<_TestFailed>().Select(failed => messages.OfType<_TestStarting>().Single(ts => ts.TestUniqueID == failed.TestUniqueID).TestDisplayName).OrderBy(x => x), 			displayName => Assert.Equal(""MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \""Hello\"", y: 42)"", displayName), 			displayName => Assert.Equal(""MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \""Hello\"", y: 6)"", displayName), 			displayName => Assert.Equal(""MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \""world!\"", y: 42)"", displayName), 			displayName => Assert.Equal(""MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \""world!\"", y: 5)"", displayName) 		); 	}  	class SampleUsage 	{ 		public static int[] Numbers = { 42, 5, 6 }; 		public static string[] Strings = { ""Hello"", ""world!"" }; 		public static MatrixTheoryData<string, int> MatrixData = new(Strings, Numbers);  		[Theory] 		[MemberData(nameof(MatrixData))] 		public void MyTestMethod(string x, int y) 		{ 			Assert.Equal(y, x.Length); 		} 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core.tests\RecordTests.cs,"using System; using System.Threading.Tasks; using Xunit;  public class RecordTests { 	public class MethodsWithoutReturnValues 	{ 		[Fact] 		public void Exception() 		{ 			static void testCode() => throw new InvalidOperationException();  			var ex = Record.Exception(testCode);  			Assert.NotNull(ex); 			Assert.IsType<InvalidOperationException>(ex); 		}  		[Fact] 		public void NoException() 		{ 			static void testCode() 			{ }  			var ex = Record.Exception(testCode);  			Assert.Null(ex); 		} 	}  	public class MethodsReturningTask 	{ 		[Fact] 		public async ValueTask Exception() 		{ 			static Task testCode() => Task.Run(() => throw new InvalidOperationException());  			var ex = await Record.ExceptionAsync(testCode);  			Assert.NotNull(ex); 			Assert.IsType<InvalidOperationException>(ex); 		}  		[Fact] 		public async ValueTask NoException() 		{ 			static Task testCode() => Task.Run(() => { });  			var ex = await Record.ExceptionAsync(testCode);  			Assert.Null(ex); 		} 	}  	public class MethodsReturningValueTask 	{ 		[Fact] 		public async ValueTask Exception() 		{ 			static ValueTask testCode() => throw new InvalidOperationException();  			var ex = await Record.ExceptionAsync(testCode);  			Assert.NotNull(ex); 			Assert.IsType<InvalidOperationException>(ex); 		}  		[Fact] 		public async ValueTask NoException() 		{ 			static ValueTask testCode() => default;  			var ex = await Record.ExceptionAsync(testCode);  			Assert.Null(ex); 		} 	}  	public class MethodsWithReturnValues 	{ 		[Fact] 		public void GuardClause() 		{ 			static object testCode() => Task.Run(() => { });  			var ex = Record.Exception(() => Record.Exception(testCode));  			Assert.IsType<InvalidOperationException>(ex); 			Assert.Equal(""You must call Assert.ThrowsAsync, Assert.DoesNotThrowAsync, or Record.ExceptionAsync when testing async code."", ex.Message); 		}  		[Fact] 		public void Exception() 		{ 			var accessor = new StubAccessor();  			var ex = Record.Exception(() => accessor.FailingProperty);  			Assert.NotNull(ex); 			Assert.IsType<InvalidOperationException>(ex); 		}  		[Fact] 		public void NoException() 		{ 			var accessor = new StubAccessor();  			var ex = Record.Exception(() => accessor.SuccessfulProperty);  			Assert.Null(ex); 		}  		class StubAccessor 		{ 			public int SuccessfulProperty { get; set; }  			public int FailingProperty 			{ 				get { throw new InvalidOperationException(); } 			} 		} 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core.tests\ResolveGenericMethodTests.cs,"using System; using System.Collections.Generic; using System.Linq; using Xunit; using Xunit.Internal; using Xunit.Sdk; using Xunit.v3;  public class ResolveGenericMethodTests { 	public static IEnumerable<object?[]> ResolveGenericType_TestData() 	{ 		// Method() 		yield return new object?[] 		{ 			nameof(NoGenericParameters_NoParameters), 			new object[0], 			new Type[0] 		};  		// Method(int) 		yield return new object?[] 		{ 			nameof(NoGenericParameters_OneParameter), 			new object?[] { 1 }, 			new Type[0] 		};  		// Method<T>() 		yield return new object?[] 		{ 			nameof(OneGenericParameter_NotUsed_NoParameters), 			new object[0], 			new Type[] { typeof(object) } 		};  		// Method<T>(T) non-null 		yield return new object?[] 		{ 			nameof(OneGenericParameter_Used_OneParameter), 			new object?[] { 1 }, 			new Type[] { typeof(int) } 		};  		// Method<T>(T) null 		yield return new object?[] 		{ 			nameof(OneGenericParameter_Used_OneParameter), 			new object?[] { null }, 			new Type[] { typeof(object) } 		};  		// Method<T>(T) array 		yield return new object?[] 		{ 			nameof(OneGenericParameter_Used_OneParameter), 			new object?[] { new int[5] }, 			new Type[] { typeof(int[]) } 		};  		// Method<T>(T, T) matching 		yield return new object?[] 		{ 			nameof(OneGenericParameter_UsedTwice_TwoParameters), 			new object?[] { 1, 2 }, 			new Type[] { typeof(int) } 		};  		// Method<T>(T, T) non matching 		yield return new object?[] 		{ 			nameof(OneGenericParameter_UsedTwice_TwoParameters), 			new object?[] { 1, ""2"" }, 			new Type[] { typeof(int) } 		};  		// Method<T>(T, int) 		yield return new object?[] 		{ 			nameof(OneGenericParameter_UsedOnceFirst_TwoParameters), 			new object?[] { ""1"", 2 }, 			new Type[] { typeof(string) } 		};  		// Method<T>(int, T) 		yield return new object?[] 		{ 			nameof(OneGenericParameter_UsedOnceSecond_TwoParameters), 			new object?[] { 1, ""2"" }, 			new Type[] { typeof(string) } 		};  		// Method<T>(int) 		yield return new object?[] 		{ 			nameof(OneGenericParameter_NotUsed_OneParameter), 			new object?[] { 1 }, 			new Type[] { typeof(object) } 		};  		// Method<T, U>() 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_NoneUsed_NoParameters), 			new object[0], 			new Type[] { typeof(object), typeof(object) } 		};  		// Method<T, U>(int) 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_NoneUsed_OneParameter), 			new object?[] { 1 }, 			new Type[] { typeof(object), typeof(object) } 		};  		// Method<T, U>(int, long) 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_NoneUsed_TwoParameters), 			new object?[] { 1, 2L }, 			new Type[] { typeof(object), typeof(object) } 		};  		// Method<T, U>(T) 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_OnlyFirstUsed_OneParameter), 			new object?[] { 1 }, 			new Type[] { typeof(int), typeof(object) } 		};  		// Method<T, U>(U) 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_OnlySecondUsed_OneParameter), 			new object?[] { 1 }, 			new Type[] { typeof(object), typeof(int) } 		};  		// Method<T, U>(T, T) matching 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_OnlyFirstUsed_TwoParameters), 			new object?[] { 1, 2 }, 			new Type[] { typeof(int), typeof(object) } 		};  		// Method<T, U>(T, T) unmatching 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_OnlyFirstUsed_TwoParameters), 			new object?[] { 1, ""2"" }, 			new Type[] { typeof(int), typeof(object) } 		};  		// Method<T, U>(U, U) matching 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_OnlySecondUsed_TwoParameters), 			new object?[] { 1, 2 }, 			new Type[] { typeof(object), typeof(int) } 		};  		// Method<T, U>(U, U) unmatching 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_OnlySecondUsed_TwoParameters), 			new object?[] { 1, ""2"" }, 			new Type[] { typeof(object), typeof(int) } 		};  		// Method<T, U>(T, U) with normal inputs 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_TwoUsed_TwoParameters), 			new object?[] { 5, null }, 			new Type[] { typeof(int), typeof(object) } 		};  		// Method<T, U>(T, U) with array inputs 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_TwoUsed_TwoParameters), 			new object?[] { new int[1], new string[1] }, 			new Type[] { typeof(int[]), typeof(string[]) } 		};  		// Method<T, U>(T, int) 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_FirstUsedFirst_TwoParameters), 			new object?[] { ""5"", 5 }, 			new Type[] { typeof(string), typeof(object) } 		};  		// Method<T, U>(U, int) 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_SecondUsedFirst_TwoParameters), 			new object?[] { ""5"", 5 }, 			new Type[] { typeof(object), typeof(string) } 		};  		// Method<T, U>(int, U) 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_FirstUsedSecond_TwoParameters), 			new object?[] { 5, ""5"" }, 			new Type[] { typeof(string), typeof(object) } 		};  		// Method<T, U>(int, U) 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_SecondUsedSecond_TwoParameters), 			new object?[] { 5, ""5"" }, 			new Type[] { typeof(object), typeof(string) } 		};  		// Method<T>(T[]>) 		yield return new object?[] 		{ 			nameof(GenericArrayTest), 			new object?[] { new int[5] }, 			new Type[] { typeof(int) } 		};  		// Method<T>(ref T>) 		yield return new object?[] 		{ 			nameof(GenericRefTest), 			new object?[] { ""abc"" }, 			new Type[] { typeof(string) } 		};  		// Method<T>(Generic<T>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Used), 			new object?[] { new GenericClass<string>() }, 			new Type[] { typeof(string) } 		};  		// Method<T>(Generic<string>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Unused), 			new object?[] { new GenericClass<string>() }, 			new Type[] { typeof(object) } 		};  		// Method(Generic<string>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric1_NoGenericParameters), 			new object?[] { new GenericClass<string>() }, 			new Type[0] 		};  		// Method<T>(Generic<T[]>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Array), 			new object?[] { new GenericClass<string[]>() }, 			new Type[] { typeof(string) } 		};  		// Method<T>(Generic<T?>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Nullable), 			new object?[] { new GenericClass<int?>() }, 			new Type[] { typeof(int) } 		};  		// Method<T>(Generic<T>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Used), 			new object?[] { new GenericClass<GenericClass<string>>() }, 			new Type[] { typeof(GenericClass<string>) } 		};  		// Method<T>(Generic<Generic<T>>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric1_OneGenericParameter_Recursive), 			new object?[] { new GenericClass<GenericClass<string>>() }, 			new Type[] { typeof(string) } 		};  		// Method<T>(Generic<T>[]) 		yield return new object?[] 		{ 			nameof(GenericArrayOfEmbeddedGeneric1_OneGenericParameter), 			new object?[] { new GenericClass<int>[1] }, 			new Type[] { typeof(int) } 		};  		// Method<T>(T?[]) 		yield return new object?[] 		{ 			nameof(GenericArrayOfGenericNullable1_OneGenericParameter), 			new object?[] { new int?[1] }, 			new Type[] { typeof(int) } 		};  		// Method<T, U>(Generic2<T, U>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric2_TwoGenericParameters_SameType), 			new object?[] { new GenericClass2<string, int>() }, 			new Type[] { typeof(string), typeof(int) } 		};  		// Method<T>(Generic2<T, int>) 		yield return new object?[] 		{ 			nameof(EmbeddedGenericGeneric2_OneGenericParameter_First), 			new object?[] { new GenericClass2<string, int>() }, 			new Type[] { typeof(string) } 		};  		// Method<T>(Generic2<string, T>) 		yield return new object?[] 		{ 			nameof(EmbeddedGenericGeneric2_OneGenericParameter_Second), 			new object?[] { new GenericClass2<string, int>() }, 			new Type[] { typeof(int) } 		};  		// Method<T>(Generic2<string, int>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric2_OneGeneric_Unused), 			new object?[] { new GenericClass2<string, int>() }, 			new Type[] { typeof(object) } 		};  		// Method(Generic2<string, int>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric2_NotGeneric), 			new object?[] { new GenericClass2<string, int>() }, 			new Type[0] 		};  		// Method<T, U>(Generic2<T, int>, Generic2<ulong, T>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest1), 			new object?[] { new GenericClass2<string, int>(), new GenericClass2<ulong, long>() }, 			new Type[] { typeof(string), typeof(long) } 		};  		// Method<T, U>(Generic2<T, int>, Generic2<T, long>) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest2), 			new object?[] { new GenericClass2<string, int>(), new GenericClass2<ulong, long>() }, 			new Type[] { typeof(string), typeof(ulong) } 		};  		// Method<T, U>(Generic2<string, T>, Generic2<T, long) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest3), 			new object?[] { new GenericClass2<string, int>(), new GenericClass2<ulong, long>() }, 			new Type[] { typeof(int), typeof(ulong) } 		};  		// Method<T, U>(Generic2<string, T>, Generic2<ulong, T) 		yield return new object?[] 		{ 			nameof(EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest4), 			new object?[] { new GenericClass2<string, int>(), new GenericClass2<ulong, long>() }, 			new Type[] { typeof(int), typeof(long) } 		};  		// Stress test 		yield return new object?[] 		{ 			nameof(CrazyGenericMethod), 			new object?[] { new GenericClass3<GenericClass<bool>, GenericClass2<GenericClass3<ulong, long, int>, string>, uint>() }, 			new Type[] { typeof(bool), typeof(ulong), typeof(long), typeof(object), typeof(uint) } 		};  		// Func test 		yield return new object?[] 		{ 			nameof(FuncTestMethod), 			new object?[] { new int[] { 4, 5, 6, 7 }, 0, 0, new Func<int, float>(i => i + 0.5f) }, 			new Type[] { typeof(float) } 		};  		yield return new object?[] 		{ 			nameof(FuncTestMethod), 			new object?[] { new int[] { 4, 5, 6, 7 }, 0, 1, new Func<int, double>(i => i + 0.5d) }, 			new Type[] { typeof(double) } 		};  		yield return new object?[] 		{ 			nameof(FuncTestMethod), 			new object?[] { new int[] { 4, 5, 6, 7 }, 0, 2, new Func<int, int>(i => i) }, 			new Type[] { typeof(int) } 		}; 	}  	public static IEnumerable<object?[]> ResolveGenericType_MismatchedGenericTypeArguments_TestData() 	{ 		// SubClass: GenericBaseClass<int> -> GenericBaseClass<T> 		yield return new object?[] 		{ 			nameof(OneGenericParameter_GenericBaseClass), 			new object?[] { new ImplementsGeneric1BaseClass() }, 			new Type[] { typeof(int) } 		};  		// SubClass: BaseClass<int, string> -> BaseClass<T, U> 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_GenericBaseClass), 			new object?[] { new ImplementsGeneric2BaseClass() }, 			new Type[] { typeof(int), typeof(uint) } 		};  		// SubClass<T>: BaseClass<T, string> -> BaseClass<T, U> 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_GenericBaseClass), 			new object?[] { new GenericImplements2BaseClass<int>() }, 			new Type[] { typeof(int), typeof(string) } 		};  		// SubClass<T, U>: BaseClass<U> -> BaseClass<T> 		yield return new object?[] 		{ 			nameof(OneGenericParameter_GenericBaseClass), 			new object?[] { new GenericImplements1BaseClass<int, string>() }, 			new Type[] { typeof(string) } 		};  		// SubClass<T, U>: (SubClass<T, U>: BaseClass<U>) -> BaseClass<T> 		yield return new object?[] 		{ 			nameof(OneGenericParameter_GenericBaseClass), 			new object?[] { new GenericImplements2SubClassOf1BaseClass<int, string>() }, 			new Type[] { typeof(string) } 		};  		// Class: Interface<int> -> Interface<T> 		yield return new object?[] 		{ 			nameof(OneGenericParameter_GenericInterface), 			new object?[] { new ImplementsGeneric1Interface() }, 			new Type[] { typeof(int) } 		};  		// Class: Interface<int, string> -> Interface<T, U> 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_GenericInterface), 			new object?[] { new ImplementsGeneric2Interface() }, 			new Type[] { typeof(int), typeof(uint) } 		};  		// Class<T>: Interface<T, string> -> Interface<T, U> 		yield return new object?[] 		{ 			nameof(TwoGenericParameters_GenericInterface), 			new object?[] { new GenericImplements2Interface<int>() }, 			new Type[] { typeof(int), typeof(string) } 		};  		// SubClass<T, U>: Interface<U> -> Interface<T> 		yield return new object?[] 		{ 			nameof(OneGenericParameter_GenericInterface), 			new object?[] { new GenericImplements1Interface<int, string>() }, 			new Type[] { typeof(string) } 		};  		// SubClass<T, U>: (SubClass<T, U>: Interface<U>) -> Interface<T> 		yield return new object?[] 		{ 			nameof(OneGenericParameter_GenericInterface), 			new object?[] { new GenericImplements2SubClassOf1Interface<int, string>() }, 			new Type[] { typeof(string) } 		};  		// SubClass<T, U>: (Interface<T, U>: Interface<U>) -> Interface<T> 		yield return new object?[] 		{ 			nameof(OneGenericParameter_GenericInterface), 			new object?[] { new GenericImplements2InterfaceOf1Interface<int, string>() }, 			new Type[] { typeof(string) } 		};  		// SubClass<T, U>: OtherInterface<T>, Interface<U> -> Interface<T> 		yield return new object?[] 		{ 			nameof(OneGenericParameter_GenericInterface), 			new object?[] { new GenericImplementsTwo1Interfaces<int, string>() }, 			new Type[] { typeof(string) } 		}; 	}  	[Theory(DisableDiscoveryEnumeration = true)] 	[MemberData(nameof(ResolveGenericType_TestData))] 	[MemberData(nameof(ResolveGenericType_MismatchedGenericTypeArguments_TestData))] 	public static void ResolveGenericType(string methodName, object?[] parameters, Type[] expected) 	{ 		var methodInfo = typeof(ResolveGenericMethodTests).GetMethod(methodName); 		Assert.NotNull(methodInfo);  		_IMethodInfo method = Reflector.Wrap(methodInfo); 		_ITypeInfo[] actual = method.ResolveGenericTypes(parameters); 		Assert.Equal(expected, actual.Select(t => ((ReflectionTypeInfo)t).Type)); 	}  #pragma warning disable xUnit1013 // Public method should be marked as test 	public static void NoGenericParameters_NoParameters() { } 	public static void NoGenericParameters_OneParameter(int i) { } 	public static void OneGenericParameter_NotUsed_NoParameters<T>() { } 	public static void OneGenericParameter_NotUsed_OneParameter<T>(int i) { } 	public static void TwoGenericParameters_NoneUsed_NoParameters<T, U>() { } 	public static void TwoGenericParameters_NoneUsed_OneParameter<T, U>(int i) { } 	public static void TwoGenericParameters_NoneUsed_TwoParameters<T, U>(int i, long l) { }  	public static void OneGenericParameter_Used_OneParameter<T>(T t) { } 	public static void OneGenericParameter_UsedTwice_TwoParameters<T>(T t1, T t2) { } 	public static void OneGenericParameter_UsedOnceFirst_TwoParameters<T>(T t1, int i) { } 	public static void OneGenericParameter_UsedOnceSecond_TwoParameters<T>(int i, T t1) { }  	public static void TwoGenericParameters_OnlyFirstUsed_TwoParameters<T, U>(T t1, T t2) { } 	public static void TwoGenericParameters_OnlySecondUsed_TwoParameters<T, U>(U u1, U u) { } 	public static void TwoGenericParameters_OnlyFirstUsed_OneParameter<T, U>(T t) { } 	public static void TwoGenericParameters_OnlySecondUsed_OneParameter<T, U>(U u) { } 	public static void TwoGenericParameters_TwoUsed_TwoParameters<T, U>(T t, U u) { } 	public static void TwoGenericParameters_FirstUsedFirst_TwoParameters<T, U>(T t, int i) { } 	public static void TwoGenericParameters_SecondUsedFirst_TwoParameters<T, U>(U u, int i) { } 	public static void TwoGenericParameters_FirstUsedSecond_TwoParameters<T, U>(int i, T t) { } 	public static void TwoGenericParameters_SecondUsedSecond_TwoParameters<T, U>(int i, U u) { }  	public static void GenericArrayTest<T>(T[] value) { }  	public static void GenericRefTest<T>(ref T value) { }  	public static void EmbeddedGeneric1_OneGenericParameter_Used<T>(GenericClass<T> value) { } 	public static void EmbeddedGeneric1_OneGenericParameter_Unused<T>(GenericClass<string> value) { } 	public static void EmbeddedGeneric1_NoGenericParameters(GenericClass<string> value) { }  	public static void EmbeddedGeneric1_OneGenericParameter_Array<T>(GenericClass<T[]> generic) { } 	public static void EmbeddedGeneric1_OneGenericParameter_Nullable<T>(GenericClass<T?> generic) where T : struct { }  	public static void EmbeddedGeneric1_OneGenericParameter_Recursive<T>(GenericClass<GenericClass<T>> generic) { }  	public static void GenericArrayOfEmbeddedGeneric1_OneGenericParameter<T>(GenericClass<T>[] generic) { } 	public static void GenericArrayOfGenericNullable1_OneGenericParameter<T>(T?[] generic) where T : struct { }  	public static void EmbeddedGeneric2_TwoGenericParameters_SameType<T, U>(GenericClass2<T, U> t) { } 	public static void EmbeddedGenericGeneric2_OneGenericParameter_First<T>(GenericClass2<T, int> t) { } 	public static void EmbeddedGenericGeneric2_OneGenericParameter_Second<T>(GenericClass2<string, T> t) { }  	public static void EmbeddedGeneric2_OneGeneric_Unused<T>(GenericClass2<string, int> t) { } 	public static void EmbeddedGeneric2_NotGeneric(GenericClass2<string, int> t) { }  	public static void EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest1<T, U>(GenericClass2<T, int> t1, GenericClass2<ulong, U> t2) { } 	public static void EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest2<T, U>(GenericClass2<T, int> t1, GenericClass2<U, long> t2) { } 	public static void EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest3<T, U>(GenericClass2<string, T> t1, GenericClass2<U, long> t2) { } 	public static void EmbeddedGeneric2_TwoGenericParameters_DifferentTypeTest4<T, U>(GenericClass2<string, T> t1, GenericClass2<ulong, U> t2) { }  	public static void CrazyGenericMethod<T, U, V, W, X>(GenericClass3<GenericClass<T>, GenericClass2<GenericClass3<U, V, int>, string>, X> gen) { }  	public static void FuncTestMethod<TResult>(IEnumerable<int> source, int start, int length, Func<int, TResult> selector) { }  	public static void OneGenericParameter_GenericBaseClass<T>(GenericClass<T> x) { } 	public static void TwoGenericParameters_GenericBaseClass<T, U>(GenericClass2<T, U> x) { }  	public static void OneGenericParameter_GenericInterface<T>(Generic1Interface<T> x) { } 	public static void TwoGenericParameters_GenericInterface<T, U>(Generic2Interface<T, U> x) { } #pragma warning restore xUnit1013 // Public method should be marked as test  	public class GenericClass<T> { } 	public class GenericClass2<T, U> { } 	public class GenericClass3<T, U, V> { }  	public interface Generic1Interface<T> { } 	public interface OtherGeneric1Interface<T> { } 	public interface Generic2Interface<T, U> { }  	public class ImplementsGeneric1BaseClass : GenericClass<int> { } 	public class ImplementsGeneric2BaseClass : GenericClass2<int, uint> { }  	public class ImplementsGeneric1Interface : Generic1Interface<int> { } 	public class ImplementsGeneric2Interface : Generic2Interface<int, uint> { }  	public class GenericImplements2BaseClass<T> : GenericClass2<T, string> { } 	public class GenericImplements2Interface<T> : Generic2Interface<T, string> { }  	public class GenericImplements1Interface<T, U> : Generic1Interface<U> { } 	public class GenericImplementsTwo1Interfaces<T, U> : OtherGeneric1Interface<T>, Generic1Interface<U> { } 	public interface GenericExtends1Interface<T, U> : Generic1Interface<U> { } 	public class GenericImplements1BaseClass<T, U> : GenericClass<U> { }  	public class GenericImplements2SubClassOf1Interface<T, U> : GenericImplements1Interface<T, U> { } 	public class GenericImplements2InterfaceOf1Interface<T, U> : GenericExtends1Interface<T, U> { } 	public class GenericImplements2SubClassOf1BaseClass<T, U> : GenericImplements1BaseClass<T, U> { } }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.core.tests\TestContextTests.cs,"using Xunit;  public class TestContextTests { 	[Fact] 	public static void AmbientTestContextIsAvailableInTest() 	{ 		var context = TestContext.Current;  		Assert.NotNull(context); 		// Test 		Assert.Equal(TestEngineStatus.Running, context.TestStatus); 		Assert.Equal(TestPipelineStage.TestExecution, context.PipelineStage); 		var test = context.Test; 		Assert.NotNull(test); 		Assert.Equal($""{nameof(TestContextTests)}.{nameof(AmbientTestContextIsAvailableInTest)}"", test.TestDisplayName); 		Assert.Null(context.TestState); 		// Test case 		Assert.Equal(TestEngineStatus.Running, context.TestCaseStatus); 		Assert.Same(test.TestCase, context.TestCase); 		// Test method 		Assert.Equal(TestEngineStatus.Running, context.TestMethodStatus); 		Assert.Same(test.TestCase.TestMethod, context.TestMethod); 		// Test class 		Assert.Equal(TestEngineStatus.Running, context.TestClassStatus); 		Assert.Same(test.TestCase.TestMethod!.TestClass, context.TestClass); 		// Test collection 		Assert.Equal(TestEngineStatus.Running, context.TestCollectionStatus); 		Assert.Same(test.TestCase.TestCollection, context.TestCollection); 		// Test assembly 		Assert.Equal(TestEngineStatus.Running, context.TestAssemblyStatus); 		Assert.Same(test.TestCase.TestCollection.TestAssembly, context.TestAssembly); 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.console\CommandLine.cs,"using System; using System.Collections.Generic; using System.Globalization; using System.Reflection; using Xunit.Internal; using Xunit.Runner.Common;  namespace Xunit.Runner.SystemConsole;  /// <summary> /// INTERNAL CLASS. DO NOT USE. /// </summary> public class CommandLine : CommandLineParserBase { 	/// <summary/> 	protected CommandLine( 		IReadOnlyList<IRunnerReporter> reporters, 		string[] args) 			: base(reporters, null, args) 	{ 		AddParsers(); 	}  	/// <summary/> 	public CommandLine( 		string? reporterFolder, 		string[] args) 			: base(null, reporterFolder, args) 	{ 		AddParsers(); 	}  	private void AddParsers() 	{ 		// General options 		AddParser( 			""parallel"", OnParallel, CommandLineGroup.General, ""<option>"", 			""set parallelization based on option"", 			""  none        - turn off all parallelization"", 			""  collections - only parallelize collections [default]"", 			""  assemblies  - only parallelize assemblies"", 			""  all         - parallelize assemblies & collections"" 		);  		// .NET Framework options 		AddParser( 			""appdomains"", OnAppDomains, CommandLineGroup.NetFramework, ""<option>"", 			""choose an app domain mode"", 			""  required    - force app domains on"", 			""  denied      - force app domains off"", 			""  ifavailable - use app domains if they're available [default]"" 		); 		AddParser(""noshadow"", OnNoShadow, CommandLineGroup.NetFramework, null, ""do not shadow copy assemblies"");  		// Deprecated options 		AddHiddenParser(""noappdomain"", OnNoAppDomain); 	}  	void AddAssembly( 		string assemblyFileName, 		string? configFileName, 		int? seed) 	{ 		if (!FileExists(assemblyFileName)) 			throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, ""assembly not found: {0}"", assemblyFileName)); 		if (configFileName is not null && !FileExists(configFileName)) 			throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, ""config file not found: {0}"", configFileName));  		var targetFramework = AssemblyUtility.GetTargetFramework(assemblyFileName); 		var projectAssembly = new XunitProjectAssembly(Project) 		{ 			AssemblyFileName = GetFullPath(assemblyFileName), 			ConfigFileName = GetFullPath(configFileName), 			TargetFramework = targetFramework 		};  		ConfigReader.Load(projectAssembly.Configuration, projectAssembly.AssemblyFileName, projectAssembly.ConfigFileName); 		projectAssembly.Configuration.Seed = seed ?? projectAssembly.Configuration.Seed;  		Project.Add(projectAssembly); 	}  	/// <summary/> 	protected override Assembly LoadAssembly(string dllFile) => #if NETFRAMEWORK 		Assembly.LoadFile(dllFile); #else 		Assembly.Load(new AssemblyName(Path.GetFileNameWithoutExtension(dllFile))); #endif  	void OnAppDomains(KeyValuePair<string, string?> option) 	{ 		if (option.Value is null) 			throw new ArgumentException(""missing argument for -appdomains"");  		var appDomainSupport = option.Value switch 		{ 			""denied"" => AppDomainSupport.Denied, 			""ifavailable"" => AppDomainSupport.IfAvailable, 			""required"" => AppDomainSupport.Required, 			_ => throw new ArgumentException(""incorrect argument value for -appdomains (must be 'denied', 'required', or 'ifavailable')""), 		};  		foreach (var projectAssembly in Project.Assemblies) 			projectAssembly.Configuration.AppDomain = appDomainSupport; 	}  	void OnNoAppDomain(KeyValuePair<string, string?> option) 	{ 		GuardNoOptionValue(option); 		foreach (var projectAssembly in Project.Assemblies) 			projectAssembly.Configuration.AppDomain = AppDomainSupport.Denied; 	}  	void OnNoShadow(KeyValuePair<string, string?> option) 	{ 		GuardNoOptionValue(option); 		foreach (var projectAssembly in Project.Assemblies) 			projectAssembly.Configuration.ShadowCopy = false; 	}  	/// <summary/> 	public XunitProject Parse() 	{ 		if (Project.Assemblies.Count > 0) 			throw new InvalidOperationException(""Parse may only be called once"");  		var argsStartIndex = 0;  		while (argsStartIndex < Args.Length) 		{ 			if (Args[argsStartIndex].StartsWith(""-"", StringComparison.Ordinal)) 				break;  			var assemblyFileName = Args[argsStartIndex++];  			int? seed = null; 			int seedIndex = assemblyFileName.LastIndexOf(':'); 			if (seedIndex > 1)  // Skip colon from drive letter 			{ 				var seedValueText = assemblyFileName.Substring(seedIndex + 1); 				if (!int.TryParse(seedValueText, NumberStyles.None, NumberFormatInfo.CurrentInfo, out int parsedValue) || parsedValue < 0) 					throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, ""invalid seed value '{0}' (must be an integer in the range of 0 - 2147483647)"", seedValueText));  				seed = parsedValue; 				assemblyFileName = assemblyFileName.Substring(0, seedIndex); 			}  			if (IsConfigFile(assemblyFileName)) 				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, ""expecting assembly, got config file: {0}"", assemblyFileName));  			string? configFileName = null; 			if (argsStartIndex < Args.Length) 			{ 				var value = Args[argsStartIndex]; 				if (!value.StartsWith(""-"", StringComparison.Ordinal) && IsConfigFile(value)) 				{ 					configFileName = value; 					++argsStartIndex; 				} 			}  			AddAssembly(assemblyFileName, configFileName, seed); 		}  		return ParseInternal(argsStartIndex); 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.console\ConsoleRunner.cs,"using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.Diagnostics; using System.Globalization; using System.IO; using System.Linq; using System.Reflection; using System.Runtime.InteropServices; using System.Text; using System.Threading.Tasks; using System.Xml.Linq; using Xunit.Internal; using Xunit.Runner.Common; using Xunit.v3;  namespace Xunit.Runner.SystemConsole;  sealed class ConsoleRunner { 	readonly string[] args; 	volatile bool cancel; 	readonly object consoleLock = new(); 	readonly ConcurrentDictionary<string, ExecutionSummary> completionMessages = new(); 	bool failed; 	IRunnerLogger? logger;  	public ConsoleRunner( 		string[] args, 		object? consoleLock = null) 	{ 		this.args = Guard.ArgumentNotNull(args); 		this.consoleLock = consoleLock ?? new object(); 	}  	public async ValueTask<int> EntryPoint() 	{ 		Console.OutputEncoding = Encoding.UTF8;  		var globalInternalDiagnosticMessages = false; 		var noColor = false;  		try 		{ 			var runnerFolder = Path.GetDirectoryName(typeof(Program).Assembly.Location); 			var commandLine = new CommandLine(runnerFolder, args);  			if (args.Length == 0 || commandLine.HelpRequested) 			{ 				PrintHeader();  				var executableName = Path.GetFileNameWithoutExtension(Assembly.GetExecutingAssembly().GetLocalCodeBase());  				Console.WriteLine(""Copyright (C) .NET Foundation.""); 				Console.WriteLine(); 				Console.WriteLine(""usage: {0} <assemblyFile>[:seed] [configFile] [assemblyFile[:seed] [configFile]...] [options] [reporter] [resultFormat filename [...]]"", executableName); 				Console.WriteLine(); 				Console.WriteLine(""Note: Configuration files must end in .json (for JSON) or .config (for XML)""); 				Console.WriteLine(""      XML is supported for v1 and v2 only, on .NET Framework only""); 				Console.WriteLine(""      JSON is supported for v2 and later, on all supported platforms"");  				commandLine.PrintUsage();  				return 2; 			}  			var project = commandLine.Parse(); 			if (project.Assemblies.Count == 0) 				throw new ArgumentException(""must specify at least one assembly"");  			AppDomain.CurrentDomain.UnhandledException += OnUnhandledException;  			Console.CancelKeyPress += (sender, e) => 			{ 				if (!cancel) 				{ 					Console.WriteLine(""Canceling... (Press Ctrl+C again to terminate)""); 					cancel = true; 					e.Cancel = true; 				} 			};  			if (project.Configuration.PauseOrDefault) 			{ 				Console.Write(""Press any key to start execution...""); 				Console.ReadKey(true); 				Console.WriteLine(); 			}  			if (project.Configuration.DebugOrDefault) 				Debugger.Launch();  			var globalDiagnosticMessages = project.Assemblies.Any(a => a.Configuration.DiagnosticMessagesOrDefault); 			globalInternalDiagnosticMessages = project.Assemblies.Any(a => a.Configuration.InternalDiagnosticMessagesOrDefault); 			noColor = project.Configuration.NoColorOrDefault; 			logger = new ConsoleRunnerLogger(!noColor, consoleLock); 			var globalDiagnosticMessageSink = ConsoleDiagnosticMessageSink.TryCreate(consoleLock, noColor, globalDiagnosticMessages, globalInternalDiagnosticMessages); 			var reporter = project.RunnerReporter; 			var reporterMessageHandler = await reporter.CreateMessageHandler(logger, globalDiagnosticMessageSink);  			if (!reporter.ForceNoLogo && !project.Configuration.NoLogoOrDefault) 				PrintHeader();  			var failCount = 0;  			if (project.Configuration.List is not null) 				await ListProject(project); 			else 				failCount = await RunProject(project, reporterMessageHandler);  			if (cancel) 				return -1073741510;    // 0xC000013A: The application terminated as a result of a CTRL+C  			if (project.Configuration.WaitOrDefault) 			{ 				Console.WriteLine(); 				Console.Write(""Press any key to continue...""); 				Console.ReadKey(); 				Console.WriteLine(); 			}  			return project.Configuration.IgnoreFailures == true || failCount == 0 ? 0 : 1; 		} 		catch (Exception ex) 		{ 			if (!noColor) 				ConsoleHelper.SetForegroundColor(ConsoleColor.Red);  			Console.WriteLine(""error: {0}"", ex.Message);  			if (globalInternalDiagnosticMessages) 			{ 				if (!noColor) 					ConsoleHelper.SetForegroundColor(ConsoleColor.DarkGray);  				Console.WriteLine(ex.StackTrace); 			}  			return ex is ArgumentException ? 3 : 4; 		} 		finally 		{ 			if (!noColor) 				ConsoleHelper.ResetColor(); 		} 	}  	async ValueTask ListProject(XunitProject project) 	{ 		var (listOption, listFormat) = project.Configuration.List!.Value; 		var testCasesByAssembly = new Dictionary<string, List<_TestCaseDiscovered>>();  		foreach (var assembly in project.Assemblies) 		{ 			var assemblyFileName = Guard.ArgumentNotNull(assembly.AssemblyFileName);  			// Default to false for console runners 			assembly.Configuration.PreEnumerateTheories ??= false;  			// Setup discovery and execution options with command-line overrides 			var discoveryOptions = _TestFrameworkOptions.ForDiscovery(assembly.Configuration);  			var assemblyDisplayName = Path.GetFileNameWithoutExtension(assemblyFileName); 			var appDomainSupport = assembly.Configuration.AppDomainOrDefault; 			var shadowCopy = assembly.Configuration.ShadowCopyOrDefault; 			var longRunningSeconds = assembly.Configuration.LongRunningTestSecondsOrDefault;  			using var _ = AssemblyHelper.SubscribeResolveForAssembly(assemblyFileName); 			await using var controller = XunitFrontController.ForDiscoveryAndExecution(assembly);  			using var discoverySink = new TestDiscoverySink(() => cancel);  			var settings = new FrontControllerFindSettings(discoveryOptions, assembly.Configuration.Filters); 			controller.Find(discoverySink, settings); 			discoverySink.Finished.WaitOne();  			testCasesByAssembly.Add(assemblyFileName, discoverySink.TestCases); 		}  		ConsoleProjectLister.List(testCasesByAssembly, listOption, listFormat); 	}  	void OnUnhandledException( 		object sender, 		UnhandledExceptionEventArgs e) 	{ 		if (e.ExceptionObject is Exception ex) 			Console.WriteLine(ex.ToString()); 		else 			Console.WriteLine(""Error of unknown type thrown in application domain"");  		Environment.Exit(1); 	}  	static void PrintHeader() 	{ #if NET472 		var buildTarget = ""net472"" + #elif NET48 		var buildTarget = ""net48"" + #elif NET481 		var buildTarget = ""net481"" + #else #error Unknown target framework #endif  #if BUILD_X86 		""/x86""; #else 		""/AnyCPU""; #endif  		Console.WriteLine( 			""xUnit.net v3 Console Runner v{0} [{1}] ({2}-bit {3})"", 			ThisAssembly.AssemblyInformationalVersion, 			buildTarget, 			IntPtr.Size * 8, 			RuntimeInformation.FrameworkDescription 		); 	}  	async ValueTask<int> RunProject( 		XunitProject project, 		_IMessageSink reporterMessageHandler) 	{ 		XElement? assembliesElement = null; 		var clockTime = Stopwatch.StartNew(); 		var xmlTransformers = TransformFactory.GetXmlTransformers(project); 		var needsXml = xmlTransformers.Count > 0; 		// TODO: Parallelize the ones that will parallelize, and then run the rest sequentially? 		var parallelizeAssemblies = project.Assemblies.All(assembly => assembly.Configuration.ParallelizeAssemblyOrDefault);  		if (needsXml) 			assembliesElement = TransformFactory.CreateAssembliesElement();  		var originalWorkingFolder = Directory.GetCurrentDirectory();  		if (parallelizeAssemblies) 		{ 			var tasks = project.Assemblies.Select( 				assembly => Task.Run( 					() => RunProjectAssembly( 						assembly, 						needsXml, 						reporterMessageHandler 					).AsTask() 				) 			);  			var results = Task.WhenAll(tasks).GetAwaiter().GetResult(); 			foreach (var assemblyElement in results.WhereNotNull()) 				assembliesElement?.Add(assemblyElement); 		} 		else 		{ 			foreach (var assembly in project.Assemblies) 			{ 				var assemblyElement = await RunProjectAssembly( 					assembly, 					needsXml, 					reporterMessageHandler 				);  				if (assemblyElement is not null) 					assembliesElement?.Add(assemblyElement); 			} 		}  		clockTime.Stop();  		if (!completionMessages.IsEmpty) 		{ 			var summaries = new TestExecutionSummaries { ElapsedClockTime = clockTime.Elapsed }; 			foreach (var completionMessage in completionMessages.OrderBy(kvp => kvp.Key)) 				summaries.Add(completionMessage.Key, completionMessage.Value); 			reporterMessageHandler.OnMessage(summaries); 		}  		Directory.SetCurrentDirectory(originalWorkingFolder);  		if (assembliesElement is not null) 		{ 			TransformFactory.FinishAssembliesElement(assembliesElement); 			xmlTransformers.ForEach(transformer => transformer(assembliesElement)); 		}  		return failed ? 1 : completionMessages.Values.Sum(summary => summary.Failed + summary.Errors); 	}  	async ValueTask<XElement?> RunProjectAssembly( 		XunitProjectAssembly assembly, 		bool needsXml, 		_IMessageSink reporterMessageHandler) 	{ 		if (cancel) 			return null;  		var assemblyElement = needsXml ? new XElement(""assembly"") : null;  		try 		{ 			var assemblyFileName = Guard.ArgumentNotNull(assembly.AssemblyFileName);  			// Default to false for console runners 			assembly.Configuration.PreEnumerateTheories ??= false;  			// Setup discovery and execution options with command-line overrides 			var discoveryOptions = _TestFrameworkOptions.ForDiscovery(assembly.Configuration); 			var executionOptions = _TestFrameworkOptions.ForExecution(assembly.Configuration);  			var assemblyDisplayName = Path.GetFileNameWithoutExtension(assemblyFileName); 			var noColor = assembly.Project.Configuration.NoColorOrDefault; 			var diagnosticMessages = assembly.Configuration.DiagnosticMessagesOrDefault; 			var internalDiagnosticMessages = assembly.Configuration.InternalDiagnosticMessagesOrDefault; 			var diagnosticMessageSink = ConsoleDiagnosticMessageSink.TryCreate(consoleLock, noColor, diagnosticMessages, internalDiagnosticMessages, assemblyDisplayName); 			var appDomainSupport = assembly.Configuration.AppDomainOrDefault; 			var shadowCopy = assembly.Configuration.ShadowCopyOrDefault; 			var longRunningSeconds = assembly.Configuration.LongRunningTestSecondsOrDefault;  			using var _ = AssemblyHelper.SubscribeResolveForAssembly(assemblyFileName, diagnosticMessageSink); 			await using var controller = XunitFrontController.ForDiscoveryAndExecution(assembly, diagnosticMessageSink: diagnosticMessageSink);  			var appDomain = (controller.CanUseAppDomains, appDomainSupport) switch 			{ 				(false, AppDomainSupport.Required) => throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, ""AppDomains were required but assembly '{0}' does not support them"", assembly.AssemblyFileName)), 				(false, _) => AppDomainOption.NotAvailable, 				(true, AppDomainSupport.Denied) => AppDomainOption.Disabled, 				(true, _) => AppDomainOption.Enabled, 			};  			IExecutionSink resultsSink = new DelegatingSummarySink( 				assembly, 				discoveryOptions, 				executionOptions, 				appDomain, 				shadowCopy, 				reporterMessageHandler, 				() => cancel, 				(summary, _) => completionMessages.TryAdd(controller.TestAssemblyUniqueID, summary) 			);  			if (assemblyElement is not null) 				resultsSink = new DelegatingXmlCreationSink(resultsSink, assemblyElement); 			if (longRunningSeconds > 0 && diagnosticMessageSink is not null) 				resultsSink = new DelegatingLongRunningTestDetectionSink(resultsSink, TimeSpan.FromSeconds(longRunningSeconds), diagnosticMessageSink); 			if (assembly.Configuration.FailSkipsOrDefault) 				resultsSink = new DelegatingFailSkipSink(resultsSink); 			if (assembly.Configuration.FailWarnsOrDefault) 				resultsSink = new DelegatingFailWarnSink(resultsSink);  			using (resultsSink) 			{ 				var settings = new FrontControllerFindAndRunSettings(discoveryOptions, executionOptions, assembly.Configuration.Filters); 				controller.FindAndRun(resultsSink, settings); 				resultsSink.Finished.WaitOne();  				if (assembly.Configuration.StopOnFailOrDefault && resultsSink.ExecutionSummary.Failed != 0) 				{ 					Console.WriteLine(""Canceling due to test failure...""); 					cancel = true; 				} 			} 		} 		catch (Exception ex) 		{ 			failed = true;  			var e = ex; 			while (e is not null) 			{ 				Console.WriteLine(""{0}: {1}"", e.GetType().FullName, e.Message);  				if (assembly.Configuration.InternalDiagnosticMessagesOrDefault) 					Console.WriteLine(e.StackTrace);  				e = e.InnerException; 			} 		}  		return assemblyElement; 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.console\Program.cs,"using System; using System.Threading.Tasks;  namespace Xunit.Runner.SystemConsole;  public static class Program { 	[STAThread] 	public static Task<int> Main(string[] args) => 		new ConsoleRunner(args).EntryPoint().AsTask(); }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.console.tests\CommandLineTests.cs,"using System; using System.Collections.Generic; using System.Linq; using System.Linq.Expressions; using Xunit; using Xunit.Runner.Common; using Xunit.Runner.SystemConsole;  public class CommandLineTests { 	public class UnknownOption 	{ 		[Fact] 		public static void UnknownOptionThrows() 		{ 			var commandLine = new TestableCommandLine(""-unknown"");  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal(""unknown option: -unknown"", exception.Message); 		} 	}  	public class Project 	{ 		[Fact] 		public static void AssemblyDoesNotExist_Throws() 		{ 			var commandLine = new TestableCommandLine(""badAssembly.dll"");  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal(""assembly not found: badAssembly.dll"", exception.Message); 		}  		[Theory] 		[InlineData(""badConfig.config"")] 		[InlineData(""badConfig.json"")] 		public static void AssemblyExists_ConfigFileDoesNotExist_Throws(string configFile) 		{ 			var commandLine = new TestableCommandLine(""assembly1.dll"", configFile);  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal(""config file not found: "" + configFile, exception.Message); 		}  		[Fact] 		public static void SingleAssembly_NoConfigFile() 		{ 			var commandLine = new TestableCommandLine(""assembly1.dll"");  			var project = commandLine.Parse();  			var assembly = Assert.Single(project.Assemblies); 			Assert.Equal(""/full/path/assembly1.dll"", assembly.AssemblyFileName); 			Assert.Null(assembly.ConfigFileName); 		}  		[Fact] 		public static void SingleAssembly_WithConfigFile() 		{ 			var commandLine = new TestableCommandLine(""assembly1.dll"", ""assembly1.json"");  			var project = commandLine.Parse();  			var assembly = Assert.Single(project.Assemblies); 			Assert.Equal(""/full/path/assembly1.dll"", assembly.AssemblyFileName); 			Assert.Equal(""/full/path/assembly1.json"", assembly.ConfigFileName); 		}  		[Fact] 		public static void MultipleAssemblies_NoConfigFiles() 		{ 			var arguments = new[] { ""assemblyName.dll"", ""assemblyName2.dll"" }; 			var commandLine = new TestableCommandLine(arguments);  			var project = commandLine.Parse();  			Assert.Collection( 				project.Assemblies, 				a => 				{ 					Assert.Equal(""/full/path/assemblyName.dll"", a.AssemblyFileName); 					Assert.Null(a.ConfigFileName); 				}, 				a => 				{ 					Assert.Equal(""/full/path/assemblyName2.dll"", a.AssemblyFileName); 					Assert.Null(a.ConfigFileName); 				} 			); 		}  		[Theory] 		[InlineData(""assembly2.config"")] 		[InlineData(""assembly2.json"")] 		public static void MultipleAssembliesOneWithConfig(string configFile) 		{ 			var arguments = new[] { ""assemblyName.dll"", ""assemblyName2.dll"", configFile }; 			var commandLine = new TestableCommandLine(arguments);  			var project = commandLine.Parse();  			Assert.Collection( 				project.Assemblies, 				item => 				{ 					Assert.Equal(""/full/path/assemblyName.dll"", item.AssemblyFileName); 					Assert.Null(item.ConfigFileName); 				}, 				item => 				{ 					Assert.Equal(""/full/path/assemblyName2.dll"", item.AssemblyFileName); 					Assert.Equal($""/full/path/{configFile}"", item.ConfigFileName); 				} 			); 		}  		[Theory] 		[InlineData(""assembly1.config"", ""assembly2.config"")] 		[InlineData(""assembly1.config"", ""assembly2.json"")] 		[InlineData(""assembly1.json"", ""assembly2.config"")] 		[InlineData(""assembly1.json"", ""assembly2.json"")] 		public static void TwoConfigFiles_Throws( 			string configFile1, 			string configFile2) 		{ 			var arguments = new[] { ""assemblyName.dll"", configFile1, configFile2 }; 			var commandLine = new TestableCommandLine(arguments);  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal(""expecting assembly, got config file: "" + configFile2, exception.Message); 		} 	}  	[Collection(""Switches Test Collection"")] 	public class Switches : IDisposable 	{ 		readonly string? _originalNoColorValue;  		public Switches() 		{ 			_originalNoColorValue = Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor); 			Environment.SetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor, null); 		}  		public void Dispose() => 			Environment.SetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor, _originalNoColorValue);  		static readonly (string Switch, Expression<Func<XunitProject, bool>> Accessor)[] SwitchOptionsList = new (string, Expression<Func<XunitProject, bool>>)[] 		{ 			(""-debug"", project => project.Configuration.DebugOrDefault), 			(""-diagnostics"", project => project.Assemblies.All(a => a.Configuration.DiagnosticMessagesOrDefault)), 			(""-failskips"", project => project.Assemblies.All(a => a.Configuration.FailSkipsOrDefault)), 			(""-ignorefailures"", project => project.Configuration.IgnoreFailuresOrDefault), 			(""-internaldiagnostics"", project => project.Assemblies.All(a => a.Configuration.InternalDiagnosticMessagesOrDefault)), 			(""-noautoreporters"", project => project.Configuration.NoAutoReportersOrDefault), 			(""-nocolor"", project => project.Configuration.NoColorOrDefault), 			(""-nologo"", project => project.Configuration.NoLogoOrDefault), 			(""-noshadow"", project => !project.Assemblies.Single().Configuration.ShadowCopyOrDefault), 			(""-pause"", project => project.Configuration.PauseOrDefault), 			(""-preenumeratetheories"", project => project.Assemblies.All(a => a.Configuration.PreEnumerateTheories ?? false)), 			(""-stoponfail"", project => project.Assemblies.All(a => a.Configuration.StopOnFailOrDefault)), 			(""-wait"", project => project.Configuration.WaitOrDefault), 		};  		public static readonly TheoryData<string, Expression<Func<XunitProject, bool>>> SwitchesLowerCase = 			new(SwitchOptionsList);  		public static readonly TheoryData<string, Expression<Func<XunitProject, bool>>> SwitchesUpperCase = 			new(SwitchOptionsList.Select(t => (t.Switch.ToUpperInvariant(), t.Accessor)));  		[Theory(DisableDiscoveryEnumeration = true)] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public void SwitchDefault( 			string _, 			Expression<Func<XunitProject, bool>> accessor) 		{ 			var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json""); 			var project = commandLine.Parse();  			var result = accessor.Compile().Invoke(project);  			Assert.False(result); 		}  		[Theory(DisableDiscoveryEnumeration = true)] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public void SwitchOverride( 			string @switch, 			Expression<Func<XunitProject, bool>> accessor) 		{ 			var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", @switch); 			var project = commandLine.Parse();  			var result = accessor.Compile().Invoke(project);  			Assert.True(result); 		}  		[Fact] 		public void NoColorSetsEnvironmentVariable() 		{ 			Assert.Null(Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor));  			new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-nocolor"").Parse();  			// Any set (non-null, non-empty) value is acceptable, see https://no-color.org/ 			var envValue = Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor); 			Assert.NotNull(envValue); 			Assert.NotEmpty(envValue); 		} 	}  	public class OptionsWithArguments 	{ 		public class AppDomains 		{ 			[Fact] 			public static void DefaultValueIsNull() 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Null(assembly.Configuration.AppDomain); 			}  			[Fact] 			public static void MissingValue() 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-appdomains"");  				var exception = Record.Exception(() => commandLine.Parse());  				Assert.IsType<ArgumentException>(exception); 				Assert.Equal(""missing argument for -appdomains"", exception.Message); 			}  			[Fact] 			public static void InvalidValue() 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-appdomains"", ""foo"");  				var exception = Record.Exception(() => commandLine.Parse());  				Assert.IsType<ArgumentException>(exception); 				Assert.Equal(""incorrect argument value for -appdomains (must be 'denied', 'required', or 'ifavailable')"", exception.Message); 			}  			[Theory] 			[InlineData(""required"", AppDomainSupport.Required)] 			[InlineData(""denied"", AppDomainSupport.Denied)] 			[InlineData(""ifavailable"", AppDomainSupport.IfAvailable)] 			public static void ValidValues( 				string value, 				AppDomainSupport expected) 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-appdomains"", value);  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Equal(expected, assembly.Configuration.AppDomain); 			} 		}  		public class Culture 		{ 			[Fact] 			public static void DefaultValueIsNull() 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Null(assembly.Configuration.Culture); 			}  			[Fact] 			public static void ExplicitDefaultValueIsNull() 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-culture"", ""default"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Null(assembly.Configuration.Culture); 			}  			[Fact] 			public static void InvariantCultureIsEmptyString() 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-culture"", ""invariant"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Equal(string.Empty, assembly.Configuration.Culture); 			}  			[Fact] 			public static void ValueIsPreserved() 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-culture"", ""foo"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Equal(""foo"", assembly.Configuration.Culture); 			} 		}  		public class MaxThreads 		{ 			[Fact] 			public static void DefaultValueIsNull() 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Null(assembly.Configuration.MaxParallelThreads); 			}  			[Fact] 			public static void MissingValue() 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-maxthreads"");  				var exception = Record.Exception(() => commandLine.Parse());  				Assert.IsType<ArgumentException>(exception); 				Assert.Equal(""missing argument for -maxthreads"", exception.Message); 			}  			[Theory] 			[InlineData(""abc"")] 			// Non digit 			[InlineData(""0.ax"")] 			[InlineData(""0,ax"")] 			// Missing leading digit 			[InlineData("".0x"")] 			[InlineData("",0x"")] 			public static void InvalidValues(string value) 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-maxthreads"", value);  				var exception = Record.Exception(() => commandLine.Parse());  				Assert.IsType<ArgumentException>(exception); 				Assert.Equal($""incorrect argument value for -maxthreads (must be 'default', 'unlimited', a positive number, or a multiplier in the form of '{0.0m}x')"", exception.Message); 			}  			[Theory] 			[InlineData(""default"", null)] 			[InlineData(""0"", null)] 			[InlineData(""unlimited"", -1)] 			[InlineData(""16"", 16)] 			public static void ValidValues( 				string value, 				int? expected) 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-maxthreads"", value);  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Equal(expected, assembly.Configuration.MaxParallelThreads); 			}  			[Theory] 			[InlineData(""2x"")] 			[InlineData(""2.0x"")] 			[InlineData(""2,0x"")] 			public static void MultiplierValue(string value) 			{ 				var expected = Environment.ProcessorCount * 2; 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-maxthreads"", value);  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Equal(expected, assembly.Configuration.MaxParallelThreads); 			} 		}  		public class Parallelization 		{ 			[Fact] 			public static void ParallelizationOptionsAreNullByDefault() 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 				{ 					Assert.Null(assembly.Configuration.ParallelizeAssembly); 					Assert.Null(assembly.Configuration.ParallelizeTestCollections); 				} 			}  			[Fact] 			public static void FailsWithoutOptionOrWithIncorrectOptions() 			{ 				var commandLine1 = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-parallel""); 				var exception1 = Record.Exception(() => commandLine1.Parse()); 				Assert.IsType<ArgumentException>(exception1); 				Assert.Equal(""missing argument for -parallel"", exception1.Message);  				var commandLine2 = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-parallel"", ""nonsense""); 				var exception2 = Record.Exception(() => commandLine2.Parse()); 				Assert.IsType<ArgumentException>(exception2); 				Assert.Equal(""incorrect argument value for -parallel"", exception2.Message); 			}  			[Theory] 			[InlineData(""none"", false, false)] 			[InlineData(""collections"", false, true)] 			[InlineData(""assemblies"", true, false)] 			[InlineData(""all"", true, true)] 			public static void ParallelCanBeTurnedOn( 				string parallelOption, 				bool expectedAssembliesParallelization, 				bool expectedCollectionsParallelization) 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", ""-parallel"", parallelOption);  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 				{ 					Assert.Equal(expectedAssembliesParallelization, assembly.Configuration.ParallelizeAssembly); 					Assert.Equal(expectedCollectionsParallelization, assembly.Configuration.ParallelizeTestCollections); 				} 			} 		} 	}  	public class Filters 	{ 		[Fact] 		public static void DefaultFilters() 		{ 			var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"");  			var project = commandLine.Parse();  			var filters = project.Assemblies.Single().Configuration.Filters; 			Assert.Empty(filters.IncludedTraits); 			Assert.Empty(filters.ExcludedTraits); 			Assert.Empty(filters.IncludedNamespaces); 			Assert.Empty(filters.ExcludedNamespaces); 			Assert.Empty(filters.IncludedClasses); 			Assert.Empty(filters.ExcludedClasses); 			Assert.Empty(filters.IncludedMethods); 			Assert.Empty(filters.ExcludedMethods); 		}  		static readonly (string Switch, Expression<Func<XunitProject, ICollection<string>>> Accessor)[] SwitchOptionsList = 			new (string, Expression<Func<XunitProject, ICollection<string>>>)[] 			{ 				(""-namespace"", project => project.Assemblies.Single().Configuration.Filters.IncludedNamespaces), 				(""-nonamespace"", project => project.Assemblies.Single().Configuration.Filters.ExcludedNamespaces), 				(""-class"", project => project.Assemblies.Single().Configuration.Filters.IncludedClasses), 				(""-noclass"", project => project.Assemblies.Single().Configuration.Filters.ExcludedClasses), 				(""-method"", project => project.Assemblies.Single().Configuration.Filters.IncludedMethods), 				(""-nomethod"", project => project.Assemblies.Single().Configuration.Filters.ExcludedMethods), 			};  		public static readonly TheoryData<string, Expression<Func<XunitProject, ICollection<string>>>> SwitchesLowerCase = 			new(SwitchOptionsList);  		public static readonly TheoryData<string, Expression<Func<XunitProject, ICollection<string>>>> SwitchesUpperCase = 			new(SwitchOptionsList.Select(t => (t.Switch.ToUpperInvariant(), t.Accessor)));  		[Theory(DisableDiscoveryEnumeration = true)] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public static void MissingOptionValue( 			string @switch, 			Expression<Func<XunitProject, ICollection<string>>> _) 		{ 			var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", @switch);  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal($""missing argument for {@switch.ToLowerInvariant()}"", exception.Message); 		}  		[Theory(DisableDiscoveryEnumeration = true)] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public static void SingleValidArgument( 			string @switch, 			Expression<Func<XunitProject, ICollection<string>>> accessor) 		{ 			var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", @switch, ""value1""); 			var project = commandLine.Parse();  			var results = accessor.Compile().Invoke(project);  			var item = Assert.Single(results.OrderBy(x => x)); 			Assert.Equal(""value1"", item); 		}  		[Theory(DisableDiscoveryEnumeration = true)] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public static void MultipleValidArguments( 			string @switch, 			Expression<Func<XunitProject, ICollection<string>>> accessor) 		{ 			var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", @switch, ""value2"", @switch, ""value1""); 			var project = commandLine.Parse();  			var results = accessor.Compile().Invoke(project);  			Assert.Collection(results.OrderBy(x => x), 				item => Assert.Equal(""value1"", item), 				item => Assert.Equal(""value2"", item) 			); 		}  		public class Traits 		{ 			static readonly (string Switch, Expression<Func<XunitProject, Dictionary<string, List<string>>>> Accessor)[] SwitchOptionsList = 				new (string Switch, Expression<Func<XunitProject, Dictionary<string, List<string>>>> Accessor)[] 				{ 					(""-trait"", project => project.Assemblies.Single().Configuration.Filters.IncludedTraits), 					(""-notrait"", project => project.Assemblies.Single().Configuration.Filters.ExcludedTraits), 				};  			static readonly string[] BadFormatValues = 				new string[] 				{ 					// Missing equals 					""foobar"", 					// Missing value 					""foo="", 					// Missing name 					""=bar"", 					// Double equal signs 					""foo=bar=baz"", 				};  			public static readonly TheoryData<string, Expression<Func<XunitProject, Dictionary<string, List<string>>>>> SwitchesLowerCase = 				new(SwitchOptionsList);  			public static readonly TheoryData<string, Expression<Func<XunitProject, Dictionary<string, List<string>>>>> SwitchesUpperCase = 				new(SwitchOptionsList.Select(x => (x.Switch.ToUpperInvariant(), x.Accessor)));  			public static readonly TheoryData<string, string> SwitchesWithOptionsLowerCase = 				new(SwitchOptionsList.SelectMany(tuple => BadFormatValues.Select(value => (tuple.Switch, value))));  			public static readonly TheoryData<string, string> SwitchesWithOptionsUpperCase = 				new(SwitchOptionsList.SelectMany(tuple => BadFormatValues.Select(value => (tuple.Switch.ToUpperInvariant(), value))));  			[Theory(DisableDiscoveryEnumeration = true)] 			[MemberData(nameof(SwitchesLowerCase))] 			[MemberData(nameof(SwitchesUpperCase))] 			public static void SingleValidTraitArgument( 				string @switch, 				Expression<Func<XunitProject, Dictionary<string, List<string>>>> accessor) 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", @switch, ""foo=bar""); 				var project = commandLine.Parse();  				var traits = accessor.Compile().Invoke(project);  				Assert.Single(traits); 				Assert.Single(traits[""foo""]); 				Assert.Contains(""bar"", traits[""foo""]); 			}  			[Theory(DisableDiscoveryEnumeration = true)] 			[MemberData(nameof(SwitchesLowerCase))] 			[MemberData(nameof(SwitchesUpperCase))] 			public static void MultipleValidTraitArguments_SameName( 				string @switch, 				Expression<Func<XunitProject, Dictionary<string, List<string>>>> accessor) 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", @switch, ""foo=bar"", @switch, ""foo=baz""); 				var project = commandLine.Parse();  				var traits = accessor.Compile().Invoke(project);  				Assert.Single(traits); 				Assert.Equal(2, traits[""foo""].Count()); 				Assert.Contains(""bar"", traits[""foo""]); 				Assert.Contains(""baz"", traits[""foo""]); 			}  			[Theory(DisableDiscoveryEnumeration = true)] 			[MemberData(nameof(SwitchesLowerCase))] 			[MemberData(nameof(SwitchesUpperCase))] 			public static void MultipleValidTraitArguments_DifferentName( 				string @switch, 				Expression<Func<XunitProject, Dictionary<string, List<string>>>> accessor) 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", @switch, ""foo=bar"", @switch, ""baz=biff""); 				var project = commandLine.Parse();  				var traits = accessor.Compile().Invoke(project);  				Assert.Equal(2, traits.Count); 				Assert.Single(traits[""foo""]); 				Assert.Contains(""bar"", traits[""foo""]); 				Assert.Single(traits[""baz""]); 				Assert.Contains(""biff"", traits[""baz""]); 			}  			[Theory(DisableDiscoveryEnumeration = true)] 			[MemberData(nameof(SwitchesLowerCase))] 			[MemberData(nameof(SwitchesUpperCase))] 			public static void MissingOptionValue( 				string @switch, 				Expression<Func<XunitProject, Dictionary<string, List<string>>>> _) 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", @switch);  				var exception = Record.Exception(() => commandLine.Parse());  				Assert.IsType<ArgumentException>(exception); 				Assert.Equal($""missing argument for {@switch.ToLowerInvariant()}"", exception.Message); 			}  			[Theory] 			[MemberData(nameof(SwitchesWithOptionsLowerCase))] 			[MemberData(nameof(SwitchesWithOptionsUpperCase))] 			public static void ImproperlyFormattedOptionValue( 				string @switch, 				string optionValue) 			{ 				var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", @switch, optionValue);  				var exception = Record.Exception(() => commandLine.Parse());  				Assert.IsType<ArgumentException>(exception); 				Assert.Equal($""incorrect argument format for {@switch.ToLowerInvariant()} (should be \""name=value\"")"", exception.Message); 			} 		} 	}  	public class Transforms 	{ 		public static readonly TheoryData<string> SwitchesLowerCase = 			new(TransformFactory.AvailableTransforms.Select(x => $""-{x.ID}""));  		public static readonly TheoryData<string> SwitchesUpperCase = 			new(TransformFactory.AvailableTransforms.Select(x => $""-{x.ID.ToUpperInvariant()}""));  		[Theory] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public static void OutputMissingFilename(string @switch) 		{ 			var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", @switch);  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal($""missing filename for {@switch}"", exception.Message); 		}  		[Theory] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public static void Output(string @switch) 		{ 			var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"", @switch, ""outputFile"");  			var project = commandLine.Parse();  			var output = Assert.Single(project.Configuration.Output); 			Assert.Equal(@switch.Substring(1), output.Key, ignoreCase: true); 			Assert.Equal(""outputFile"", output.Value); 		} 	}  	public class Reporters : IDisposable 	{ 		readonly IDisposable environmentCleanup;  		public Reporters() => 			environmentCleanup = EnvironmentHelper.NullifyEnvironmentalReporters();  		public void Dispose() => 			environmentCleanup.Dispose();  		[Fact] 		public void NoReporters_UsesDefaultReporter() 		{ 			var commandLine = new TestableCommandLine(""assemblyName.dll"", ""no-config.json"");  			var project = commandLine.Parse();  			Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter); 		}  		[Fact] 		public void NoExplicitReporter_NoEnvironmentallyEnabledReporters_UsesDefaultReporter() 		{ 			var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: false); 			var commandLine = new TestableCommandLine(new[] { implicitReporter }, ""assemblyName.dll"", ""no-config.json"");  			var project = commandLine.Parse();  			Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter); 		}  		[Fact] 		public void ExplicitReporter_NoEnvironmentalOverride_UsesExplicitReporter() 		{ 			var explicitReporter = Mocks.RunnerReporter(""switch""); 			var commandLine = new TestableCommandLine(new[] { explicitReporter }, ""assemblyName.dll"", ""no-config.json"", ""-switch"");  			var project = commandLine.Parse();  			Assert.Same(explicitReporter, project.RunnerReporter); 		}  		[Fact] 		public void ExplicitReporter_WithEnvironmentalOverride_UsesEnvironmentalOverride() 		{ 			var explicitReporter = Mocks.RunnerReporter(""switch""); 			var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var commandLine = new TestableCommandLine(new[] { explicitReporter, implicitReporter }, ""assemblyName.dll"", ""no-config.json"", ""-switch"");  			var project = commandLine.Parse();  			Assert.Same(implicitReporter, project.RunnerReporter); 		}  		[Fact] 		public void WithEnvironmentalOverride_WithEnvironmentalOverridesDisabled_UsesDefaultReporter() 		{ 			var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var commandLine = new TestableCommandLine(new[] { implicitReporter }, ""assemblyName.dll"", ""no-config.json"", ""-noautoreporters"");  			var project = commandLine.Parse();  			Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter); 		}  		[Fact] 		public void NoExplicitReporter_SelectsFirstEnvironmentallyEnabledReporter() 		{ 			var explicitReporter = Mocks.RunnerReporter(""switch""); 			var implicitReporter1 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var implicitReporter2 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var commandLine = new TestableCommandLine(new[] { explicitReporter, implicitReporter1, implicitReporter2 }, ""assemblyName.dll"", ""no-config.json"");  			var project = commandLine.Parse();  			Assert.Same(implicitReporter1, project.RunnerReporter); 		} 	}  	class TestableCommandLine : CommandLine 	{ 		public TestableCommandLine(params string[] args) 			: base(Array.Empty<IRunnerReporter>(), args) 		{ }  		public TestableCommandLine( 			IReadOnlyList<IRunnerReporter> reporters, 			params string[] args) 				: base(reporters, args) 		{ }  		protected override bool FileExists(string? path) => 			path?.StartsWith(""bad"") != true && path != ""fileName"";  		protected override string? GetFullPath(string? fileName) => 			fileName is null ? null : $""/full/path/{fileName}""; 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.inproc.console\CommandLine.cs,"using System; using System.Collections.Generic; using System.Globalization; using System.IO; using System.Reflection; using Xunit.Internal; using Xunit.Runner.Common;  namespace Xunit.Runner.InProc.SystemConsole;  /// <summary/> public class CommandLine : CommandLineParserBase { 	readonly Assembly assembly; 	readonly string? assemblyFileName;  	/// <summary/> 	public CommandLine( 		Assembly assembly, 		string[] args, 		IReadOnlyList<IRunnerReporter>? runnerReporters = null, 		string? reporterFolder = null) 			: base(runnerReporters, reporterFolder ?? Path.GetDirectoryName(assembly.GetSafeLocation()), args) 	{ 		this.assembly = assembly; 		assemblyFileName = assembly.GetSafeLocation();  		// General options 		AddParser( 			""parallel"", OnParallel, CommandLineGroup.General, ""<option>"", 			""set parallelization based on option"", 			""  none        - turn off parallelization"", 			""  collections - parallelize by collections [default]"" 		); 	}  	void AddAssembly( 		Assembly assembly, 		string? assemblyFileName, 		string? configFileName, 		int? seed) 	{ 		if (assemblyFileName is not null && !FileExists(assemblyFileName)) 			throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, ""assembly not found: {0}"", assemblyFileName)); 		if (configFileName is not null && !FileExists(configFileName)) 			throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, ""config file not found: {0}"", configFileName));  		var targetFramework = assembly.GetTargetFramework(); 		var projectAssembly = new XunitProjectAssembly(Project) 		{ 			Assembly = assembly, 			AssemblyFileName = GetFullPath(assemblyFileName), 			ConfigFileName = GetFullPath(configFileName), 			TargetFramework = targetFramework 		};  		ConfigReader_Json.Load(projectAssembly.Configuration, projectAssembly.AssemblyFileName, projectAssembly.ConfigFileName); 		projectAssembly.Configuration.Seed = seed ?? projectAssembly.Configuration.Seed;  		Project.Add(projectAssembly); 	}  	/// <summary/> 	protected override Assembly LoadAssembly(string dllFile) => #if NETFRAMEWORK 		Assembly.LoadFile(dllFile); #else 		Assembly.Load(new AssemblyName(Path.GetFileNameWithoutExtension(dllFile))); #endif  	/// <summary/> 	public XunitProject Parse() 	{ 		if (Project.Assemblies.Count > 0) 			throw new InvalidOperationException(""Parse may only be called once"");  		var argsStartIndex = 0;  		int? seed = null; 		if (Args.Length > argsStartIndex && Args[argsStartIndex].StartsWith("":"", StringComparison.OrdinalIgnoreCase)) 		{ 			var seedValueText = Args[argsStartIndex].Substring(1); 			if (!int.TryParse(seedValueText, NumberStyles.None, NumberFormatInfo.CurrentInfo, out int parsedValue) || parsedValue < 0) 				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, ""invalid seed value '{0}' (must be an integer in the range of 0 - 2147483647)"", seedValueText));  			seed = parsedValue; 			++argsStartIndex; 		}  		string? configFileName = null; 		if (Args.Length > argsStartIndex && !Args[argsStartIndex].StartsWith(""-"", StringComparison.OrdinalIgnoreCase) && Args[argsStartIndex].EndsWith("".json"", StringComparison.OrdinalIgnoreCase)) 		{ 			configFileName = Args[argsStartIndex]; 			++argsStartIndex; 		}  		AddAssembly(assembly, assemblyFileName, configFileName, seed);  		return ParseInternal(argsStartIndex); 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.inproc.console\ConsoleRunner.cs,"using System; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Linq; using System.Reflection; using System.Runtime.InteropServices; using System.Text; using System.Threading.Tasks; using System.Xml.Linq; using Xunit.Internal; using Xunit.Runner.Common; using Xunit.Sdk; using Xunit.v3;  namespace Xunit.Runner.InProc.SystemConsole;  /// <summary> /// This class is the entry point for the in-process console-based runner used for /// xUnit.net v3 test projects. /// </summary> public class ConsoleRunner { 	readonly string[] args; 	volatile bool cancel; 	readonly object consoleLock; 	bool executed; 	bool failed; 	IRunnerLogger? logger; 	IReadOnlyList<IRunnerReporter>? runnerReporters; 	readonly Assembly testAssembly; 	readonly TestExecutionSummaries testExecutionSummaries = new();  	/// <summary> 	/// Initializes a new instance of the <see cref=""ConsoleRunner""/> class. 	/// </summary> 	/// <param name=""args"">The arguments passed to the application; typically pulled from the Main method.</param> 	/// <param name=""testAssembly"">The (optional) assembly to test; defaults to <see cref=""Assembly.GetEntryAssembly""/>.</param> 	/// <param name=""runnerReporters"">The (optional) list of runner reporters.</param> 	/// <param name=""consoleLock"">The (optional) lock used around all console output to ensure there are no write collisions.</param> 	public ConsoleRunner( 		string[] args, 		Assembly? testAssembly = null, 		IEnumerable<IRunnerReporter>? runnerReporters = null, 		object? consoleLock = null) 	{ 		this.args = Guard.ArgumentNotNull(args); 		this.testAssembly = Guard.ArgumentNotNull(""testAssembly was null, and Assembly.GetEntryAssembly() returned null; you should pass a non-null value for testAssembly"", testAssembly ?? Assembly.GetEntryAssembly(), nameof(testAssembly)); 		this.consoleLock = consoleLock ?? new object(); 		this.runnerReporters = runnerReporters.CastOrToReadOnlyList(); 	}  	/// <summary> 	/// The entry point to begin running tests. 	/// </summary> 	/// <returns>The return value intended to be returned by the Main method.</returns> 	public async ValueTask<int> EntryPoint() 	{ 		if (executed) 			throw new InvalidOperationException(""The EntryPoint method can only be called once."");  		executed = true;  		SetOutputEncoding();  		var globalInternalDiagnosticMessages = false; 		var noColor = false;  		try 		{ 			var commandLine = new CommandLine(testAssembly, args, runnerReporters);  			if (commandLine.HelpRequested) 			{ 				PrintHeader();  				Console.WriteLine(""Copyright (C) .NET Foundation.""); 				Console.WriteLine(); 				Console.WriteLine(""usage: [:seed] [path/to/configFile.json] [options] [filters] [reporter] [resultFormat filename [...]]"");  				commandLine.PrintUsage(); 				return 2; 			}  			var project = commandLine.Parse();  			AppDomain.CurrentDomain.UnhandledException += OnUnhandledException;  			Console.CancelKeyPress += (sender, e) => 			{ 				if (!cancel) 				{ 					Console.WriteLine(""Canceling... (Press Ctrl+C again to terminate)""); 					cancel = true; 					e.Cancel = true; 				} 			};  			if (project.Configuration.PauseOrDefault) 			{ 				Console.Write(""Press any key to start execution...""); 				Console.ReadKey(true); 				Console.WriteLine(); 			}  			if (project.Configuration.DebugOrDefault) 				Debugger.Launch();  			var globalDiagnosticMessages = project.Assemblies.Any(a => a.Configuration.DiagnosticMessagesOrDefault); 			globalInternalDiagnosticMessages = project.Assemblies.Any(a => a.Configuration.InternalDiagnosticMessagesOrDefault); 			noColor = project.Configuration.NoColorOrDefault; 			logger = new ConsoleRunnerLogger(!noColor, consoleLock); 			var globalDiagnosticMessageSink = ConsoleDiagnosticMessageSink.TryCreate(consoleLock, noColor, globalDiagnosticMessages, globalInternalDiagnosticMessages); 			var reporter = project.RunnerReporter; 			var reporterMessageHandler = await reporter.CreateMessageHandler(logger, globalDiagnosticMessageSink);  			if (!reporter.ForceNoLogo && !project.Configuration.NoLogoOrDefault) 				PrintHeader();  			var failCount = 0;  			if (project.Configuration.List is not null) 				await ListProject(project); 			else 				failCount = await RunProject(project, reporterMessageHandler);  			if (cancel) 				return -1073741510;    // 0xC000013A: The application terminated as a result of a CTRL+C  			if (project.Configuration.WaitOrDefault) 			{ 				Console.WriteLine(); 				Console.Write(""Press any key to continue...""); 				Console.ReadKey(); 				Console.WriteLine(); 			}  			return project.Configuration.IgnoreFailures == true || failCount == 0 ? 0 : 1; 		} 		catch (Exception ex) 		{ 			if (!noColor) 				ConsoleHelper.SetForegroundColor(ConsoleColor.Red);  			Console.WriteLine(""error: {0}"", ex.Message);  			if (globalInternalDiagnosticMessages) 			{ 				if (!noColor) 					ConsoleHelper.SetForegroundColor(ConsoleColor.DarkGray);  				Console.WriteLine(ex.StackTrace); 			}  			return ex is ArgumentException ? 3 : 4; 		} 		finally 		{ 			if (!noColor) 				ConsoleHelper.ResetColor(); 		} 	}  	async ValueTask ListProject(XunitProject project) 	{ 		var (listOption, listFormat) = project.Configuration.List!.Value; 		var testCasesByAssembly = new Dictionary<string, List<_ITestCase>>();  		foreach (var assembly in project.Assemblies) 		{ 			var assemblyFileName = Guard.ArgumentNotNull(assembly.AssemblyFileName);  			// Default to false for console runners 			assembly.Configuration.PreEnumerateTheories ??= false;  			// Setup discovery options with command line overrides 			var discoveryOptions = _TestFrameworkOptions.ForDiscovery(assembly.Configuration);  			var noColor = assembly.Project.Configuration.NoColorOrDefault; 			var diagnosticMessages = assembly.Configuration.DiagnosticMessagesOrDefault; 			var internalDiagnosticMessages = assembly.Configuration.InternalDiagnosticMessagesOrDefault; 			var diagnosticMessageSink = ConsoleDiagnosticMessageSink.TryCreate(consoleLock, noColor, diagnosticMessages, internalDiagnosticMessages);  			TestContext.SetForInitialization(diagnosticMessageSink, diagnosticMessages, internalDiagnosticMessages);  			var assemblyInfo = new ReflectionAssemblyInfo(testAssembly);  #pragma warning disable CA2007 // Cannot use ConfigureAwait here because it changes the type of disposalTracker 			await using var disposalTracker = new DisposalTracker(); #pragma warning restore CA2007 			var testFramework = ExtensibilityPointFactory.GetTestFramework(assemblyInfo); 			disposalTracker.Add(testFramework);  			// Discover & filter the tests 			var testCases = new List<_ITestCase>(); 			var testDiscoverer = testFramework.GetDiscoverer(assemblyInfo); 			await testDiscoverer.Find(testCase => { testCases.Add(testCase); return new(!cancel); }, discoveryOptions);  			var testCasesDiscovered = testCases.Count; 			var filteredTestCases = testCases.Where(assembly.Configuration.Filters.Filter).ToList();  			testCasesByAssembly.Add(assemblyFileName, filteredTestCases); 		}  		ConsoleProjectLister.List(testCasesByAssembly, listOption, listFormat); 	}  	void OnUnhandledException( 		object sender, 		UnhandledExceptionEventArgs e) 	{ 		if (e.ExceptionObject is Exception ex) 			Console.WriteLine(ex.ToString()); 		else 			Console.WriteLine(""Error of unknown type thrown in application domain"");  		Environment.Exit(1); 	}  	static void PrintHeader() => 		Console.WriteLine( 			""xUnit.net v3 In-Process Runner v{0} ({1}-bit {2})"", 			ThisAssembly.AssemblyInformationalVersion, 			IntPtr.Size * 8, 			RuntimeInformation.FrameworkDescription 		);  	/// <summary> 	/// Creates a new <see cref=""ConsoleRunner""/> instance and runs it via <see cref=""EntryPoint""/>. 	/// </summary> 	/// <param name=""args"">The arguments passed to the application; typically pulled from the Main method.</param> 	/// <param name=""testAssembly"">The (optional) assembly to test; defaults to <see cref=""Assembly.GetEntryAssembly""/>.</param> 	/// <param name=""runnerReporters"">The (optional) list of runner reporters.</param> 	/// <param name=""consoleLock"">The (optional) lock used around all console output to ensure there are no write collisions.</param> 	/// <returns>The return value intended to be returned by the Main method.</returns> 	public static ValueTask<int> Run( 		string[] args, 		Assembly? testAssembly = null, 		IEnumerable<IRunnerReporter>? runnerReporters = null, 		object? consoleLock = null) => 			new ConsoleRunner(args, testAssembly, runnerReporters, consoleLock).EntryPoint();  	async ValueTask<int> RunProject( 		XunitProject project, 		_IMessageSink reporterMessageHandler) 	{ 		XElement? assembliesElement = null; 		var clockTime = Stopwatch.StartNew(); 		var xmlTransformers = TransformFactory.GetXmlTransformers(project); 		var needsXml = xmlTransformers.Count > 0;  		if (needsXml) 			assembliesElement = TransformFactory.CreateAssembliesElement();  		var originalWorkingFolder = Directory.GetCurrentDirectory();  		var assembly = project.Assemblies.Single(); 		var assemblyElement = await RunProjectAssembly( 			assembly, 			needsXml, 			reporterMessageHandler 		);  		if (assemblyElement is not null) 			assembliesElement?.Add(assemblyElement);  		clockTime.Stop();  		testExecutionSummaries.ElapsedClockTime = clockTime.Elapsed; 		reporterMessageHandler.OnMessage(testExecutionSummaries);  		Directory.SetCurrentDirectory(originalWorkingFolder);  		if (assembliesElement is not null) 		{ 			TransformFactory.FinishAssembliesElement(assembliesElement); 			xmlTransformers.ForEach(transformer => transformer(assembliesElement)); 		}  		return failed ? 1 : testExecutionSummaries.SummariesByAssemblyUniqueID.Sum(s => s.Summary.Failed + s.Summary.Errors); 	}  	async ValueTask<XElement?> RunProjectAssembly( 		XunitProjectAssembly assembly, 		bool needsXml, 		_IMessageSink reporterMessageHandler) 	{ 		if (cancel) 			return null;  		var assemblyElement = needsXml ? new XElement(""assembly"") : null;  		try 		{ 			// Default to false for console runners 			assembly.Configuration.PreEnumerateTheories ??= false;  			// Setup discovery and execution options with command-line overrides 			var discoveryOptions = _TestFrameworkOptions.ForDiscovery(assembly.Configuration); 			var executionOptions = _TestFrameworkOptions.ForExecution(assembly.Configuration);  			var noColor = assembly.Project.Configuration.NoColorOrDefault; 			var diagnosticMessages = assembly.Configuration.DiagnosticMessagesOrDefault; 			var internalDiagnosticMessages = assembly.Configuration.InternalDiagnosticMessagesOrDefault; 			var diagnosticMessageSink = ConsoleDiagnosticMessageSink.TryCreate(consoleLock, noColor, diagnosticMessages, internalDiagnosticMessages); 			var longRunningSeconds = assembly.Configuration.LongRunningTestSecondsOrDefault;  			TestContext.SetForInitialization(diagnosticMessageSink, diagnosticMessages, internalDiagnosticMessages);  			var assemblyInfo = new ReflectionAssemblyInfo(testAssembly);  #pragma warning disable CA2007 // Cannot use ConfigureAwait here because it changes the type of disposalTracker 			await using var disposalTracker = new DisposalTracker(); #pragma warning restore CA2007 			var testFramework = ExtensibilityPointFactory.GetTestFramework(assemblyInfo); 			disposalTracker.Add(testFramework);  			var frontController = new InProcessFrontController(testFramework, assemblyInfo, assembly.ConfigFileName);  			IExecutionSink resultsSink = new DelegatingSummarySink( 				assembly, 				discoveryOptions, 				executionOptions, 				AppDomainOption.NotAvailable, 				shadowCopy: false, 				reporterMessageHandler, 				() => cancel 			);  			if (assemblyElement is not null) 				resultsSink = new DelegatingXmlCreationSink(resultsSink, assemblyElement); 			if (longRunningSeconds > 0 && diagnosticMessageSink is not null) 				resultsSink = new DelegatingLongRunningTestDetectionSink(resultsSink, TimeSpan.FromSeconds(longRunningSeconds), diagnosticMessageSink); 			if (assembly.Configuration.FailSkipsOrDefault) 				resultsSink = new DelegatingFailSkipSink(resultsSink); 			if (assembly.Configuration.FailWarnsOrDefault) 				resultsSink = new DelegatingFailWarnSink(resultsSink);  			using (resultsSink) 			{ 				await frontController.FindAndRun(resultsSink, discoveryOptions, executionOptions, assembly.Configuration.Filters.Filter);  				testExecutionSummaries.Add(frontController.TestAssemblyUniqueID, resultsSink.ExecutionSummary);  				if (assembly.Configuration.StopOnFailOrDefault && resultsSink.ExecutionSummary.Failed != 0) 				{ 					Console.WriteLine(""Canceling due to test failure...""); 					cancel = true; 				} 			} 		} 		catch (Exception ex) 		{ 			failed = true;  			var e = ex; 			while (e is not null) 			{ 				Console.WriteLine(""{0}: {1}"", e.GetType().FullName, e.Message);  				if (assembly.Configuration.InternalDiagnosticMessagesOrDefault) 					Console.WriteLine(e.StackTrace);  				e = e.InnerException; 			} 		}  		return assemblyElement; 	}  	/// <summary> 	/// Override this function to change the default output encoding for the system console. 	/// The default is set to <see cref=""Encoding.UTF8""/> to support our usage of Unicode 	/// characters in output (for example, the up and down arrows printed for pointers with 	/// mismatches assertion values). 	/// </summary> 	protected virtual void SetOutputEncoding() => 		Console.OutputEncoding = Encoding.UTF8; }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.inproc.console.tests\CommandLineTests.cs,"using System; using System.Collections.Generic; using System.Linq; using System.Linq.Expressions; using System.Reflection; using Xunit; using Xunit.Runner.Common; using Xunit.Runner.InProc.SystemConsole;  public class CommandLineTests { 	public class UnknownOption 	{ 		[Fact] 		public static void UnknownOptionThrows() 		{ 			var commandLine = new TestableCommandLine(""-unknown"");  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal(""unknown option: -unknown"", exception.Message); 		} 	}  	public class Project 	{ 		[Fact] 		public static void DefaultValues() 		{ 			var commandLine = new TestableCommandLine();  			var project = commandLine.Parse();  			var assembly = Assert.Single(project.Assemblies); 			Assert.Equal($""/full/path/{typeof(CommandLineTests).Assembly.Location}"", assembly.AssemblyFileName); 			Assert.Null(assembly.ConfigFileName); 		}  		[Fact] 		public static void ConfigFileDoesNotExist_Throws() 		{ 			var commandLine = new TestableCommandLine(""badConfig.json"");  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal(""config file not found: badConfig.json"", exception.Message); 		}  		[Fact] 		public static void ConfigFileUnsupportedFormat_Throws() 		{ 			var commandLine = new TestableCommandLine(""assembly1.config"");  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal(""unknown option: assembly1.config"", exception.Message); 		}  		[Fact] 		public static void TwoConfigFiles_Throws() 		{ 			var commandLine = new TestableCommandLine(""assembly1.json"", ""assembly2.json"");  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal(""unknown option: assembly2.json"", exception.Message); 		}  		[Fact] 		public static void WithConfigFile() 		{ 			var commandLine = new TestableCommandLine(""assembly1.json"");  			var project = commandLine.Parse();  			var assembly = Assert.Single(project.Assemblies); 			Assert.Equal(""/full/path/assembly1.json"", assembly.ConfigFileName); 		} 	}  	[Collection(""Switches Test Collection"")] 	public class Switches : IDisposable 	{ 		readonly string? _originalNoColorValue;  		public Switches() 		{ 			_originalNoColorValue = Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor); 			Environment.SetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor, null); 		}  		public void Dispose() => 			Environment.SetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor, _originalNoColorValue);  		static readonly (string Switch, Expression<Func<XunitProject, bool>> Accessor)[] SwitchOptionsList = new (string, Expression<Func<XunitProject, bool>>)[] 		{ 			(""-debug"", project => project.Configuration.DebugOrDefault), 			(""-diagnostics"", project => project.Assemblies.All(a => a.Configuration.DiagnosticMessagesOrDefault)), 			(""-failskips"", project => project.Assemblies.All(a => a.Configuration.FailSkipsOrDefault)), 			(""-ignorefailures"", project => project.Configuration.IgnoreFailuresOrDefault), 			(""-internaldiagnostics"", project => project.Assemblies.All(a => a.Configuration.InternalDiagnosticMessagesOrDefault)), 			(""-noautoreporters"", project => project.Configuration.NoAutoReportersOrDefault), 			(""-nocolor"", project => project.Configuration.NoColorOrDefault), 			(""-nologo"", project => project.Configuration.NoLogoOrDefault), 			(""-pause"", project => project.Configuration.PauseOrDefault), 			(""-preenumeratetheories"", project => project.Assemblies.All(a => a.Configuration.PreEnumerateTheories ?? false)), 			(""-stoponfail"", project => project.Assemblies.All(a => a.Configuration.StopOnFailOrDefault)), 			(""-wait"", project => project.Configuration.WaitOrDefault), 		};  		public static readonly TheoryData<string, Expression<Func<XunitProject, bool>>> SwitchesLowerCase = 			new(SwitchOptionsList);  		public static readonly TheoryData<string, Expression<Func<XunitProject, bool>>> SwitchesUpperCase = 			new(SwitchOptionsList.Select(t => (t.Switch.ToUpperInvariant(), t.Accessor)));  		[Theory(DisableDiscoveryEnumeration = true)] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public void SwitchDefault( 			string _, 			Expression<Func<XunitProject, bool>> accessor) 		{ 			var commandLine = new TestableCommandLine(""no-config.json""); 			var project = commandLine.Parse();  			var result = accessor.Compile().Invoke(project);  			Assert.False(result); 		}  		[Theory(DisableDiscoveryEnumeration = true)] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public void SwitchOverride( 			string @switch, 			Expression<Func<XunitProject, bool>> accessor) 		{ 			var commandLine = new TestableCommandLine(""no-config.json"", @switch); 			var project = commandLine.Parse();  			var result = accessor.Compile().Invoke(project);  			Assert.True(result); 		}  		[Fact] 		public void NoColorSetsEnvironmentVariable() 		{ 			Assert.Null(Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor));  			new TestableCommandLine(""no-config.json"", ""-nocolor"").Parse();  			// Any set (non-null, non-empty) value is acceptable, see https://no-color.org/ 			var envValue = Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor); 			Assert.NotNull(envValue); 			Assert.NotEmpty(envValue); 		} 	}  	public class OptionsWithArguments 	{ 		public class Culture 		{ 			[Fact] 			public static void DefaultValueIsNull() 			{ 				var commandLine = new TestableCommandLine(""no-config.json"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Null(assembly.Configuration.Culture); 			}  			[Fact] 			public static void ExplicitDefaultValueIsNull() 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", ""-culture"", ""default"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Null(assembly.Configuration.Culture); 			}  			[Fact] 			public static void InvariantCultureIsEmptyString() 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", ""-culture"", ""invariant"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Equal(string.Empty, assembly.Configuration.Culture); 			}  			[Fact] 			public static void ValueIsPreserved() 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", ""-culture"", ""foo"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Equal(""foo"", assembly.Configuration.Culture); 			} 		}  		public class MaxThreads 		{ 			[Fact] 			public static void DefaultValueIsNull() 			{ 				var commandLine = new TestableCommandLine(""no-config.json"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Null(assembly.Configuration.MaxParallelThreads); 			}  			[Fact] 			public static void MissingValue() 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", ""-maxthreads"");  				var exception = Record.Exception(() => commandLine.Parse());  				Assert.IsType<ArgumentException>(exception); 				Assert.Equal(""missing argument for -maxthreads"", exception.Message); 			}  			[Theory] 			[InlineData(""abc"")] 			// Non digit 			[InlineData(""0.ax"")] 			[InlineData(""0,ax"")] 			// Missing leading digit 			[InlineData("".0x"")] 			[InlineData("",0x"")] 			public static void InvalidValues(string value) 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", ""-maxthreads"", value);  				var exception = Record.Exception(() => commandLine.Parse());  				Assert.IsType<ArgumentException>(exception); 				Assert.Equal($""incorrect argument value for -maxthreads (must be 'default', 'unlimited', a positive number, or a multiplier in the form of '{0.0m}x')"", exception.Message); 			}  			[Theory] 			[InlineData(""default"", null)] 			[InlineData(""0"", null)] 			[InlineData(""unlimited"", -1)] 			[InlineData(""16"", 16)] 			public static void ValidValues( 				string value, 				int? expected) 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", ""-maxthreads"", value);  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Equal(expected, assembly.Configuration.MaxParallelThreads); 			}  			[Theory] 			[InlineData(""2x"")] 			[InlineData(""2.0x"")] 			[InlineData(""2,0x"")] 			public static void MultiplierValue(string value) 			{ 				var expected = Environment.ProcessorCount * 2; 				var commandLine = new TestableCommandLine(""no-config.json"", ""-maxthreads"", value);  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Equal(expected, assembly.Configuration.MaxParallelThreads); 			} 		}  		public class Parallelization 		{ 			[Fact] 			public static void ParallelizationOptionsAreNullByDefault() 			{ 				var commandLine = new TestableCommandLine(""no-config.json"");  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Null(assembly.Configuration.ParallelizeTestCollections); 			}  			[Fact] 			public static void FailsWithoutOptionOrWithIncorrectOptions() 			{ 				var commandLine1 = new TestableCommandLine(""no-config.json"", ""-parallel""); 				var exception1 = Record.Exception(() => commandLine1.Parse()); 				Assert.IsType<ArgumentException>(exception1); 				Assert.Equal(""missing argument for -parallel"", exception1.Message);  				var commandLine2 = new TestableCommandLine(""no-config.json"", ""-parallel"", ""nonsense""); 				var exception2 = Record.Exception(() => commandLine2.Parse()); 				Assert.IsType<ArgumentException>(exception2); 				Assert.Equal(""incorrect argument value for -parallel"", exception2.Message); 			}  			[Theory] 			[InlineData(""none"", false)] 			[InlineData(""collections"", true)] 			public static void ParallelCanBeTurnedOn( 				string parallelOption, 				bool expectedCollectionsParallelization) 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", ""-parallel"", parallelOption);  				var project = commandLine.Parse();  				foreach (var assembly in project.Assemblies) 					Assert.Equal(expectedCollectionsParallelization, assembly.Configuration.ParallelizeTestCollections); 			} 		} 	}  	public class Filters 	{ 		[Fact] 		public static void DefaultFilters() 		{ 			var commandLine = new TestableCommandLine(""no-config.json"");  			var project = commandLine.Parse();  			var filters = project.Assemblies.Single().Configuration.Filters; 			Assert.Empty(filters.IncludedTraits); 			Assert.Empty(filters.ExcludedTraits); 			Assert.Empty(filters.IncludedNamespaces); 			Assert.Empty(filters.ExcludedNamespaces); 			Assert.Empty(filters.IncludedClasses); 			Assert.Empty(filters.ExcludedClasses); 			Assert.Empty(filters.IncludedMethods); 			Assert.Empty(filters.ExcludedMethods); 		}  		static readonly (string Switch, Expression<Func<XunitProject, ICollection<string>>> Accessor)[] SwitchOptionsList = 			new (string, Expression<Func<XunitProject, ICollection<string>>>)[] 			{ 				(""-namespace"", project => project.Assemblies.Single().Configuration.Filters.IncludedNamespaces), 				(""-nonamespace"", project => project.Assemblies.Single().Configuration.Filters.ExcludedNamespaces), 				(""-class"", project => project.Assemblies.Single().Configuration.Filters.IncludedClasses), 				(""-noclass"", project => project.Assemblies.Single().Configuration.Filters.ExcludedClasses), 				(""-method"", project => project.Assemblies.Single().Configuration.Filters.IncludedMethods), 				(""-nomethod"", project => project.Assemblies.Single().Configuration.Filters.ExcludedMethods), 			};  		public static readonly TheoryData<string, Expression<Func<XunitProject, ICollection<string>>>> SwitchesLowerCase = 			new(SwitchOptionsList);  		public static readonly TheoryData<string, Expression<Func<XunitProject, ICollection<string>>>> SwitchesUpperCase = 			new(SwitchOptionsList.Select(t => (t.Switch.ToUpperInvariant(), t.Accessor)));  		[Theory(DisableDiscoveryEnumeration = true)] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public static void MissingOptionValue( 			string @switch, 			Expression<Func<XunitProject, ICollection<string>>> _) 		{ 			var commandLine = new TestableCommandLine(""no-config.json"", @switch);  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal($""missing argument for {@switch.ToLowerInvariant()}"", exception.Message); 		}  		[Theory(DisableDiscoveryEnumeration = true)] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public static void SingleValidArgument( 			string @switch, 			Expression<Func<XunitProject, ICollection<string>>> accessor) 		{ 			var commandLine = new TestableCommandLine(""no-config.json"", @switch, ""value1""); 			var project = commandLine.Parse();  			var results = accessor.Compile().Invoke(project);  			var item = Assert.Single(results.OrderBy(x => x)); 			Assert.Equal(""value1"", item); 		}  		[Theory(DisableDiscoveryEnumeration = true)] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public static void MultipleValidArguments( 			string @switch, 			Expression<Func<XunitProject, ICollection<string>>> accessor) 		{ 			var commandLine = new TestableCommandLine(""no-config.json"", @switch, ""value2"", @switch, ""value1""); 			var project = commandLine.Parse();  			var results = accessor.Compile().Invoke(project);  			Assert.Collection(results.OrderBy(x => x), 				item => Assert.Equal(""value1"", item), 				item => Assert.Equal(""value2"", item) 			); 		}  		public class Traits 		{ 			static readonly (string Switch, Expression<Func<XunitProject, Dictionary<string, List<string>>>> Accessor)[] SwitchOptionsList = 				new (string Switch, Expression<Func<XunitProject, Dictionary<string, List<string>>>> Accessor)[] 				{ 					(""-trait"", project => project.Assemblies.Single().Configuration.Filters.IncludedTraits), 					(""-notrait"", project => project.Assemblies.Single().Configuration.Filters.ExcludedTraits), 				};  			static readonly string[] BadFormatValues = 				new string[] 				{ 					// Missing equals 					""foobar"", 					// Missing value 					""foo="", 					// Missing name 					""=bar"", 					// Double equal signs 					""foo=bar=baz"", 				};  			public static readonly TheoryData<string, Expression<Func<XunitProject, Dictionary<string, List<string>>>>> SwitchesLowerCase = 				new(SwitchOptionsList);  			public static readonly TheoryData<string, Expression<Func<XunitProject, Dictionary<string, List<string>>>>> SwitchesUpperCase = 				new(SwitchOptionsList.Select(x => (x.Switch.ToUpperInvariant(), x.Accessor)));  			public static readonly TheoryData<string, string> SwitchesWithOptionsLowerCase = 				new(SwitchOptionsList.SelectMany(tuple => BadFormatValues.Select(value => (tuple.Switch, value))));  			public static readonly TheoryData<string, string> SwitchesWithOptionsUpperCase = 				new(SwitchOptionsList.SelectMany(tuple => BadFormatValues.Select(value => (tuple.Switch.ToUpperInvariant(), value))));  			[Theory(DisableDiscoveryEnumeration = true)] 			[MemberData(nameof(SwitchesLowerCase))] 			[MemberData(nameof(SwitchesUpperCase))] 			public static void SingleValidTraitArgument( 				string @switch, 				Expression<Func<XunitProject, Dictionary<string, List<string>>>> accessor) 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", @switch, ""foo=bar""); 				var project = commandLine.Parse();  				var traits = accessor.Compile().Invoke(project);  				Assert.Single(traits); 				Assert.Single(traits[""foo""]); 				Assert.Contains(""bar"", traits[""foo""]); 			}  			[Theory(DisableDiscoveryEnumeration = true)] 			[MemberData(nameof(SwitchesLowerCase))] 			[MemberData(nameof(SwitchesUpperCase))] 			public static void MultipleValidTraitArguments_SameName( 				string @switch, 				Expression<Func<XunitProject, Dictionary<string, List<string>>>> accessor) 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", @switch, ""foo=bar"", @switch, ""foo=baz""); 				var project = commandLine.Parse();  				var traits = accessor.Compile().Invoke(project);  				Assert.Single(traits); 				Assert.Equal(2, traits[""foo""].Count()); 				Assert.Contains(""bar"", traits[""foo""]); 				Assert.Contains(""baz"", traits[""foo""]); 			}  			[Theory(DisableDiscoveryEnumeration = true)] 			[MemberData(nameof(SwitchesLowerCase))] 			[MemberData(nameof(SwitchesUpperCase))] 			public static void MultipleValidTraitArguments_DifferentName( 				string @switch, 				Expression<Func<XunitProject, Dictionary<string, List<string>>>> accessor) 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", @switch, ""foo=bar"", @switch, ""baz=biff""); 				var project = commandLine.Parse();  				var traits = accessor.Compile().Invoke(project);  				Assert.Equal(2, traits.Count); 				Assert.Single(traits[""foo""]); 				Assert.Contains(""bar"", traits[""foo""]); 				Assert.Single(traits[""baz""]); 				Assert.Contains(""biff"", traits[""baz""]); 			}  			[Theory(DisableDiscoveryEnumeration = true)] 			[MemberData(nameof(SwitchesLowerCase))] 			[MemberData(nameof(SwitchesUpperCase))] 			public static void MissingOptionValue( 				string @switch, 				Expression<Func<XunitProject, Dictionary<string, List<string>>>> _) 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", @switch);  				var exception = Record.Exception(() => commandLine.Parse());  				Assert.IsType<ArgumentException>(exception); 				Assert.Equal($""missing argument for {@switch.ToLowerInvariant()}"", exception.Message); 			}  			[Theory] 			[MemberData(nameof(SwitchesWithOptionsLowerCase))] 			[MemberData(nameof(SwitchesWithOptionsUpperCase))] 			public static void ImproperlyFormattedOptionValue( 				string @switch, 				string optionValue) 			{ 				var commandLine = new TestableCommandLine(""no-config.json"", @switch, optionValue);  				var exception = Record.Exception(() => commandLine.Parse());  				Assert.IsType<ArgumentException>(exception); 				Assert.Equal($""incorrect argument format for {@switch.ToLowerInvariant()} (should be \""name=value\"")"", exception.Message); 			} 		} 	}  	public class Transforms 	{ 		public static readonly TheoryData<string> SwitchesLowerCase = 			new(TransformFactory.AvailableTransforms.Select(x => $""-{x.ID}""));  		public static readonly TheoryData<string> SwitchesUpperCase = 			new(TransformFactory.AvailableTransforms.Select(x => $""-{x.ID.ToUpperInvariant()}""));  		[Theory] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public static void OutputMissingFilename(string @switch) 		{ 			var commandLine = new TestableCommandLine(""no-config.json"", @switch);  			var exception = Record.Exception(() => commandLine.Parse());  			Assert.IsType<ArgumentException>(exception); 			Assert.Equal($""missing filename for {@switch}"", exception.Message); 		}  		[Theory] 		[MemberData(nameof(SwitchesLowerCase))] 		[MemberData(nameof(SwitchesUpperCase))] 		public static void Output(string @switch) 		{ 			var commandLine = new TestableCommandLine(""no-config.json"", @switch, ""outputFile"");  			var project = commandLine.Parse();  			var output = Assert.Single(project.Configuration.Output); 			Assert.Equal(@switch.Substring(1), output.Key, ignoreCase: true); 			Assert.Equal(""outputFile"", output.Value); 		} 	}  	public class Reporters : IDisposable 	{ 		readonly IDisposable environmentCleanup;  		public Reporters() => 			environmentCleanup = EnvironmentHelper.NullifyEnvironmentalReporters();  		public void Dispose() => 			environmentCleanup.Dispose();  		[Fact] 		public void NoReporters_UsesDefaultReporter() 		{ 			var commandLine = new TestableCommandLine(""no-config.json"");  			var project = commandLine.Parse();  			Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter); 		}  		[Fact] 		public void NoExplicitReporter_NoEnvironmentallyEnabledReporters_UsesDefaultReporter() 		{ 			var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: false); 			var commandLine = new TestableCommandLine(new[] { implicitReporter }, ""no-config.json"");  			var project = commandLine.Parse();  			Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter); 		}  		[Fact] 		public void ExplicitReporter_NoEnvironmentalOverride_UsesExplicitReporter() 		{ 			var explicitReporter = Mocks.RunnerReporter(""switch""); 			var commandLine = new TestableCommandLine(new[] { explicitReporter }, ""no-config.json"", ""-switch"");  			var project = commandLine.Parse();  			Assert.Same(explicitReporter, project.RunnerReporter); 		}  		[Fact] 		public void ExplicitReporter_WithEnvironmentalOverride_UsesEnvironmentalOverride() 		{ 			var explicitReporter = Mocks.RunnerReporter(""switch""); 			var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var commandLine = new TestableCommandLine(new[] { explicitReporter, implicitReporter }, ""no-config.json"", ""-switch"");  			var project = commandLine.Parse();  			Assert.Same(implicitReporter, project.RunnerReporter); 		}  		[Fact] 		public void WithEnvironmentalOverride_WithEnvironmentalOverridesDisabled_UsesDefaultReporter() 		{ 			var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var commandLine = new TestableCommandLine(new[] { implicitReporter }, ""no-config.json"", ""-noautoreporters"");  			var project = commandLine.Parse();  			Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter); 		}  		[Fact] 		public void NoExplicitReporter_SelectsFirstEnvironmentallyEnabledReporter() 		{ 			var explicitReporter = Mocks.RunnerReporter(""switch""); 			var implicitReporter1 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var implicitReporter2 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var commandLine = new TestableCommandLine(new[] { explicitReporter, implicitReporter1, implicitReporter2 }, ""no-config.json"");  			var project = commandLine.Parse();  			Assert.Same(implicitReporter1, project.RunnerReporter); 		} 	}  	class TestableCommandLine : CommandLine 	{ 		public TestableCommandLine(params string[] arguments) 			: base(Assembly.GetExecutingAssembly(), arguments) 		{ }  		public TestableCommandLine( 			IReadOnlyList<IRunnerReporter> reporters, 			params string[] arguments) 				: base(Assembly.GetExecutingAssembly(), arguments, reporters) 		{ }  		protected override bool FileExists(string? path) => 			path?.StartsWith(""badConfig."") != true && path != ""fileName"";  		protected override string? GetFullPath(string? fileName) => 			fileName is null ? null : $""/full/path/{fileName}""; 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.msbuild\xunit.cs,"#pragma warning disable CA1044 // The write-only properties in this class cannot be converted to methods becuase of MSBuild task requirements #pragma warning disable CA1721 // Properties with names that are confusing is okay because of MSBuild task requirements #pragma warning disable CA1724 // The name of this type is a shipped contract (and part of the MSBuild UX)  using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.Diagnostics; using System.Globalization; using System.IO; using System.Linq; using System.Reflection; using System.Runtime.InteropServices; using System.Threading.Tasks; using System.Xml.Linq; using Microsoft.Build.Framework; using Xunit.Internal; using Xunit.Runner.Common; using Xunit.Sdk; using Xunit.v3; using MSBuildTask = Microsoft.Build.Utilities.Task;  namespace Xunit.Runner.MSBuild;  public class xunit : MSBuildTask, ICancelableTask { 	volatile bool cancel; 	readonly ConcurrentDictionary<string, ExecutionSummary> completionMessages = new(); 	bool? diagnosticMessages; 	bool? failSkips; 	bool? failWarns; 	XunitFilters? filters; 	bool? internalDiagnosticMessages; 	IRunnerLogger? logger; 	readonly object logLock = new(); 	int? maxThreadCount; 	bool? parallelizeAssemblies; 	bool? parallelizeTestCollections; 	bool? preEnumerateTheories; 	_IMessageSink? reporterMessageHandler; 	bool? shadowCopy; 	bool? stopOnFail;  	public string? AppDomains { get; set; }  	[Required] 	public ITaskItem[]? Assemblies { get; set; }  	public string? Culture { get; set; }  	public bool DiagnosticMessages { set { diagnosticMessages = value; } }  	public string? ExcludeTraits { get; set; }  	public string? Explicit { get; set; }  	[Output] 	public int ExitCode { get; protected set; }  	public bool FailSkips { set { failSkips = value; } }  	public bool FailWarns { set { failWarns = value; } }  	protected XunitFilters Filters 	{ 		get 		{ 			if (filters is null) 			{ 				var traitParser = new TraitParser(msg => 				{ 					lock (logLock) 						Log.LogWarning(msg); 				});  				filters = new XunitFilters(); 				traitParser.Parse(IncludeTraits, filters.IncludedTraits); 				traitParser.Parse(ExcludeTraits, filters.ExcludedTraits); 			}  			return filters; 		} 	}  	public ITaskItem? Html { get; set; }  	public bool IgnoreFailures { get; set; }  	public string? IncludeTraits { get; set; }  	public bool InternalDiagnosticMessages { set { internalDiagnosticMessages = value; } }  	public ITaskItem? JUnit { get; set; }  	public string? MaxParallelThreads { get; set; }  	protected bool NeedsXml => 		Xml is not null || XmlV1 is not null || Html is not null || NUnit is not null || JUnit is not null;  	public bool NoAutoReporters { get; set; }  	public bool NoLogo { get; set; }  	public ITaskItem? NUnit { get; set; }  	public bool ParallelizeAssemblies { set { parallelizeAssemblies = value; } }  	public bool ParallelizeTestCollections { set { parallelizeTestCollections = value; } }  	public bool PreEnumerateTheories { set { preEnumerateTheories = value; } }  	public string? Reporter { get; set; }  	public bool ShadowCopy { set { shadowCopy = value; } }  	public bool StopOnFail { set { stopOnFail = value; } }  	public string? WorkingFolder { get; set; }  	public ITaskItem? Xml { get; set; }  	public ITaskItem? XmlV1 { get; set; }  	public void Cancel() 	{ 		cancel = true; 	}  	public override bool Execute() => 		ExecuteAsync().GetAwaiter().GetResult();  	async Task<bool> ExecuteAsync() 	{ 		Guard.ArgumentNotNull(Assemblies);  		RemotingUtility.CleanUpRegisteredChannels();  		XElement? assembliesElement = null;  		if (NeedsXml) 			assembliesElement = TransformFactory.CreateAssembliesElement();  		var appDomains = default(AppDomainSupport?); 		switch (AppDomains?.ToUpperInvariant()) 		{ 			case null: 				break;  			case ""IFAVAILABLE"": 				appDomains = AppDomainSupport.IfAvailable; 				break;  			case ""TRUE"": 			case ""REQUIRED"": 				appDomains = AppDomainSupport.Required; 				break;  			case ""FALSE"": 			case ""DENIED"": 				appDomains = AppDomainSupport.Denied; 				break;  			default: 				lock (logLock) 					Log.LogError(""AppDomains value '{0}' is invalid: must be one of 'IfAvailable', 'Required', or 'Denied'"", AppDomains);  				return false; 		}  		switch (MaxParallelThreads) 		{ 			case null: 			case ""default"": 			case ""0"": 				break;  			case ""unlimited"": 			case ""-1"": 				maxThreadCount = -1; 				break;  			default: 				var match = ConfigUtility.MultiplierStyleMaxParallelThreadsRegex.Match(MaxParallelThreads); 				if (match.Success && decimal.TryParse(match.Groups[1].Value, out var maxThreadMultiplier)) 					maxThreadCount = (int)(maxThreadMultiplier * Environment.ProcessorCount); 				else if (int.TryParse(MaxParallelThreads, out var threadValue) && threadValue > 0) 					maxThreadCount = threadValue; 				else 				{ 					lock (logLock) 						Log.LogError(""MaxParallelThreads value '{0}' is invalid: must be 'default', 'unlimited', a positive number, or a multiplier in the form of '0.0x'"", MaxParallelThreads);  					return false; 				}  				break; 		}  		var originalWorkingFolder = Directory.GetCurrentDirectory(); 		await using var globalDiagnosticsMessageSink = MSBuildDiagnosticMessageSink.TryCreate(Log, logLock, diagnosticMessages ?? false, internalDiagnosticMessages ?? false);  		using (AssemblyHelper.SubscribeResolveForAssembly(typeof(xunit), globalDiagnosticsMessageSink)) 		{ 			var reporter = GetReporter(); 			if (reporter is null) 				return false;  			logger = new MSBuildLogger(Log); 			reporterMessageHandler = await reporter.CreateMessageHandler(logger, globalDiagnosticsMessageSink);  			if (!NoLogo) 				lock (logLock) 					Log.LogMessage(MessageImportance.High, ""xUnit.net v3 MSBuild Runner v{0} ({1}-bit {2})"", ThisAssembly.AssemblyInformationalVersion, IntPtr.Size * 8, RuntimeInformation.FrameworkDescription);  			var project = new XunitProject(); 			foreach (var assembly in Assemblies) 			{ 				var assemblyFileName = assembly.GetMetadata(""FullPath""); 				var configFileName = assembly.GetMetadata(""ConfigFile""); 				if (configFileName is not null && configFileName.Length == 0) 					configFileName = null;  				var targetFramework = AssemblyUtility.GetTargetFramework(assemblyFileName); 				var projectAssembly = new XunitProjectAssembly(project) 				{ 					AssemblyFileName = assemblyFileName, 					ConfigFileName = configFileName, 					TargetFramework = targetFramework 				};  				ConfigReader.Load(projectAssembly.Configuration, assemblyFileName, configFileName);  				if (Culture is not null) 					projectAssembly.Configuration.Culture = Culture switch 					{ 						""default"" => null, 						""invariant"" => string.Empty, 						_ => Culture, 					};  				if (Explicit is not null) 					projectAssembly.Configuration.ExplicitOption = Explicit.ToUpperInvariant() switch 					{ 						""OFF"" => ExplicitOption.Off, 						""ON"" => ExplicitOption.On, 						""ONLY"" => ExplicitOption.Only, 						_ => throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, ""Invalid value for Explicit ('{0}'); valid values are 'off', 'on', and 'only'"", Explicit)), 					};  				if (shadowCopy.HasValue) 					projectAssembly.Configuration.ShadowCopy = shadowCopy;  				project.Add(projectAssembly); 			}  			if (WorkingFolder is not null) 				Directory.SetCurrentDirectory(WorkingFolder);  			var clockTime = Stopwatch.StartNew();  			if (!parallelizeAssemblies.HasValue) 				parallelizeAssemblies = project.Assemblies.All(assembly => assembly.Configuration.ParallelizeAssemblyOrDefault);  			if (parallelizeAssemblies.GetValueOrDefault()) 			{ 				var tasks = project.Assemblies.Select(assembly => Task.Run(() => ExecuteAssembly(assembly, appDomains).AsTask())); 				var results = await Task.WhenAll(tasks); 				foreach (var assemblyElement in results.WhereNotNull()) 					assembliesElement!.Add(assemblyElement); 			} 			else 			{ 				foreach (var assembly in project.Assemblies) 				{ 					var assemblyElement = await ExecuteAssembly(assembly, appDomains); 					if (assemblyElement is not null) 						assembliesElement!.Add(assemblyElement); 				} 			}  			clockTime.Stop();  			if (!completionMessages.IsEmpty) 			{ 				var summaries = new TestExecutionSummaries { ElapsedClockTime = clockTime.Elapsed }; 				foreach (var completionMessage in completionMessages.OrderBy(kvp => kvp.Key)) 					summaries.Add(completionMessage.Key, completionMessage.Value); 				reporterMessageHandler.OnMessage(summaries); 			} 		}  		Directory.SetCurrentDirectory(WorkingFolder ?? originalWorkingFolder);  		if (NeedsXml && assembliesElement is not null) 		{ 			TransformFactory.FinishAssembliesElement(assembliesElement);  			if (Xml is not null) 				TransformFactory.Transform(""xml"", assembliesElement, Xml.GetMetadata(""FullPath""));  			if (XmlV1 is not null) 				TransformFactory.Transform(""xmlv1"", assembliesElement, XmlV1.GetMetadata(""FullPath""));  			if (Html is not null) 				TransformFactory.Transform(""html"", assembliesElement, Html.GetMetadata(""FullPath""));  			if (NUnit is not null) 				TransformFactory.Transform(""nunit"", assembliesElement, NUnit.GetMetadata(""FullPath""));  			if (JUnit is not null) 				TransformFactory.Transform(""junit"", assembliesElement, JUnit.GetMetadata(""FullPath"")); 		}  		// ExitCode is set to 1 for test failures and -1 for Exceptions. 		return ExitCode == 0 || (ExitCode == 1 && IgnoreFailures); 	}  	protected virtual async ValueTask<XElement?> ExecuteAssembly( 		XunitProjectAssembly assembly, 		AppDomainSupport? appDomains) 	{ 		Guard.ArgumentNotNull(assembly);  		if (cancel) 			return null;  		Guard.NotNull(""Runner is misconfigured ('reporterMessageHandler' is null)"", reporterMessageHandler);  		var assemblyElement = NeedsXml ? new XElement(""assembly"") : null;  		try 		{ 			if (preEnumerateTheories.HasValue) 				assembly.Configuration.PreEnumerateTheories = preEnumerateTheories.Value; 			if (diagnosticMessages.HasValue) 				assembly.Configuration.DiagnosticMessages = diagnosticMessages.Value; 			if (internalDiagnosticMessages.HasValue) 				assembly.Configuration.InternalDiagnosticMessages = internalDiagnosticMessages.Value; 			if (failSkips.HasValue) 				assembly.Configuration.FailSkips = failSkips.Value; 			if (failWarns.HasValue) 				assembly.Configuration.FailWarns = failWarns.Value;  			if (appDomains.HasValue) 				assembly.Configuration.AppDomain = appDomains;  			// Setup discovery and execution options with command-line overrides 			var discoveryOptions = _TestFrameworkOptions.ForDiscovery(assembly.Configuration); 			var executionOptions = _TestFrameworkOptions.ForExecution(assembly.Configuration); 			if (maxThreadCount.HasValue && maxThreadCount.Value > -1) 				executionOptions.SetMaxParallelThreads(maxThreadCount); 			if (parallelizeTestCollections.HasValue) 				executionOptions.SetDisableParallelization(!parallelizeTestCollections); 			if (stopOnFail.HasValue) 				executionOptions.SetStopOnTestFail(stopOnFail);  			var assemblyDisplayName = Path.GetFileNameWithoutExtension(assembly.AssemblyFileName)!; 			await using var diagnosticMessageSink = MSBuildDiagnosticMessageSink.TryCreate(Log, logLock, diagnosticMessages ?? assembly.Configuration.DiagnosticMessagesOrDefault, internalDiagnosticMessages ?? assembly.Configuration.InternalDiagnosticMessagesOrDefault, assemblyDisplayName); 			var appDomainSupport = assembly.Configuration.AppDomainOrDefault; 			var shadowCopy = assembly.Configuration.ShadowCopyOrDefault; 			var longRunningSeconds = assembly.Configuration.LongRunningTestSecondsOrDefault;  			await using var controller = XunitFrontController.ForDiscoveryAndExecution(assembly, diagnosticMessageSink: diagnosticMessageSink);  			var appDomain = (controller.CanUseAppDomains, appDomainSupport) switch 			{ 				(false, AppDomainSupport.Required) => throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, ""AppDomains were required but assembly '{0}' does not support them"", assembly.AssemblyFileName)), 				(false, _) => AppDomainOption.NotAvailable, 				(true, AppDomainSupport.Denied) => AppDomainOption.Disabled, 				(true, _) => AppDomainOption.Enabled, 			};  			IExecutionSink resultsSink = new DelegatingSummarySink( 				assembly, 				discoveryOptions, 				executionOptions, 				appDomain, 				shadowCopy, 				reporterMessageHandler, 				() => cancel, 				(summary, _) => completionMessages.TryAdd(controller.TestAssemblyUniqueID, summary) 			);  			if (assemblyElement is not null) 				resultsSink = new DelegatingXmlCreationSink(resultsSink, assemblyElement); 			if (longRunningSeconds > 0 && diagnosticMessageSink is not null) 				resultsSink = new DelegatingLongRunningTestDetectionSink(resultsSink, TimeSpan.FromSeconds(longRunningSeconds), diagnosticMessageSink); 			if (assembly.Configuration.FailSkipsOrDefault) 				resultsSink = new DelegatingFailSkipSink(resultsSink); 			if (assembly.Configuration.FailWarnsOrDefault) 				resultsSink = new DelegatingFailWarnSink(resultsSink);  			using (resultsSink) 			{ 				var settings = new FrontControllerFindAndRunSettings(discoveryOptions, executionOptions, assembly.Configuration.Filters); 				controller.FindAndRun(resultsSink, settings); 				resultsSink.Finished.WaitOne();  				if (resultsSink.ExecutionSummary.Failed != 0 || resultsSink.ExecutionSummary.Errors != 0) 				{ 					ExitCode = 1; 					if (stopOnFail == true) 					{ 						lock (logLock) 							Log.LogMessage(MessageImportance.High, ""Canceling due to test failure..."");  						Cancel(); 					} 				} 			} 		} 		catch (Exception ex) 		{ 			var e = ex;  			lock (logLock) 				while (e is not null) 				{ 					Log.LogError(""{0}: {1}"", e.GetType().FullName, e.Message);  					if (e.StackTrace is not null) 						foreach (var stackLine in e.StackTrace.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries)) 							Log.LogError(stackLine);  					e = e.InnerException; 				}  			ExitCode = -1; 		}  		return assemblyElement; 	}  	protected virtual List<IRunnerReporter> GetAvailableRunnerReporters() 	{ 		var runnerPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetLocalCodeBase()); 		if (runnerPath is null) 			return new List<IRunnerReporter>();  		var result = RunnerReporterUtility.GetAvailableRunnerReporters(runnerPath, out var messages);  		if (messages.Count != 0) 			lock (logLock) 				foreach (var message in messages) 					Log.LogWarning(message);  		return result; 	}  	protected IRunnerReporter? GetReporter() 	{ 		var reporters = GetAvailableRunnerReporters(); 		IRunnerReporter? reporter = null; 		if (!NoAutoReporters) 			reporter = reporters.FirstOrDefault(r => r.IsEnvironmentallyEnabled);  		if (reporter is null && !string.IsNullOrWhiteSpace(Reporter)) 		{ 			reporter = reporters.FirstOrDefault(r => string.Equals(r.RunnerSwitch, Reporter, StringComparison.OrdinalIgnoreCase)); 			if (reporter is null) 			{ #pragma warning disable CA1308 // The switch list is lowercased because it's presented in the UI that way 				var switchableReporters = 					reporters 						.Where(r => !string.IsNullOrWhiteSpace(r.RunnerSwitch)) 						.Select(r => r.RunnerSwitch!.ToLowerInvariant()) 						.OrderBy(x => x) 						.ToList(); #pragma warning restore CA1308  				lock (logLock) 					if (switchableReporters.Count == 0) 						Log.LogError(""Reporter value '{0}' is invalid. There are no available reporters."", Reporter); 					else 						Log.LogError(""Reporter value '{0}' is invalid. Available reporters: {1}"", Reporter, string.Join("", "", switchableReporters));  				return null; 			} 		}  		return reporter ?? new DefaultRunnerReporter(); 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.msbuild.tests\xunitTests.cs,"using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Reflection; using System.Runtime.InteropServices; using Microsoft.Build.Framework; using NSubstitute; using Xunit; using Xunit.Runner.Common; using Xunit.Runner.MSBuild;  public class xunitTests { 	public class Execute 	{ 		[Fact, PreserveWorkingDirectory] 		public static void ChangesCurrentDirectoryWhenWorkingFolderIsNotNull() 		{ 			var tempFolder = 				Environment.GetEnvironmentVariable(""TEMP"") 				?? Environment.GetEnvironmentVariable(""TMP"") 				?? Environment.GetEnvironmentVariable(""TMPDIR"") 				?? ""/tmp"";  			tempFolder = Path.GetFullPath(tempFolder); // Ensure that the 8.3 path is not used  			// For macOS compatibility, switch to the folder and then get it, because the temp folder 			// is usually under /var/folders/... which is softlinked to /private/var/folders 			var originalDirectory = Directory.GetCurrentDirectory(); 			Directory.SetCurrentDirectory(tempFolder); 			tempFolder = Directory.GetCurrentDirectory(); 			Directory.SetCurrentDirectory(originalDirectory);  			var xunit = new Testable_xunit { WorkingFolder = tempFolder };  			xunit.Execute();  			var actual = Directory.GetCurrentDirectory(); 			var expected = tempFolder;  			if (actual[actual.Length - 1] != Path.DirectorySeparatorChar) 				actual += Path.DirectorySeparatorChar;  			if (expected[expected.Length - 1] != Path.DirectorySeparatorChar) 				expected += Path.DirectorySeparatorChar;  			Assert.Equal(expected, actual); 		}  		[Fact] 		public static void LogsWelcomeBanner() 		{ 			var xunit = new Testable_xunit();  			xunit.Execute();  			var versionAttribute = typeof(xunit).Assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>(); 			var eventArgs = Assert.IsType<BuildMessageEventArgs>(xunit.BuildEngine.Captured(x => x.LogMessageEvent(null)).Args().Single()); 			Assert.Equal($""xUnit.net v3 MSBuild Runner v{versionAttribute!.InformationalVersion} ({IntPtr.Size * 8}-bit {RuntimeInformation.FrameworkDescription})"", eventArgs.Message); 			Assert.Equal(MessageImportance.High, eventArgs.Importance); 		}  		[Fact] 		public static void ReturnsTrueWhenExitCodeIsZeroAndFailCountIsZero() 		{ 			var xunit = new Testable_xunit(exitCode: 0);  			var result = xunit.Execute();  			Assert.True(result); 		}  		[Fact] 		public static void ReturnsFalseWhenExitCodeIsNonZero() 		{ 			var xunit = new Testable_xunit(exitCode: 1);  			var result = xunit.Execute();  			Assert.False(result); 		} 	}  	public class GetReporter : IDisposable 	{ 		readonly IDisposable environmentCleanup;  		public GetReporter() => 			environmentCleanup = EnvironmentHelper.NullifyEnvironmentalReporters();  		public void Dispose() => 			environmentCleanup.Dispose();  		[Fact] 		public void NoReporters_UsesDefaultReporter() 		{ 			var xunit = new Testable_xunit();  			var reporter = xunit.GetReporter();  			Assert.IsType<DefaultRunnerReporter>(reporter); 		}  		[Fact] 		public void NoExplicitReporter_NoEnvironmentallyEnabledReporters_UsesDefaultReporter() 		{ 			var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: false); 			var xunit = new Testable_xunit(); 			xunit.AvailableReporters.Add(implicitReporter);  			var reporter = xunit.GetReporter();  			Assert.IsType<DefaultRunnerReporter>(reporter); 		}  		[Fact] 		public void ExplicitReporter_NoEnvironmentalOverride_UsesExplicitReporter() 		{ 			var explicitReporter = Mocks.RunnerReporter(""switch""); 			var xunit = new Testable_xunit { Reporter = ""switch"" }; 			xunit.AvailableReporters.Add(explicitReporter);  			var reporter = xunit.GetReporter();  			Assert.Same(explicitReporter, reporter); 		}  		[Fact] 		public void ExplicitReporter_WithEnvironmentalOverride_UsesEnvironmentalOverride() 		{ 			var explicitReporter = Mocks.RunnerReporter(""switch""); 			var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var xunit = new Testable_xunit { Reporter = ""switch"" }; 			xunit.AvailableReporters.AddRange(new[] { explicitReporter, implicitReporter });  			var reporter = xunit.GetReporter();  			Assert.Same(implicitReporter, reporter); 		}  		[Fact] 		public void WithEnvironmentalOverride_WithEnvironmentalOverridesDisabled_UsesDefaultReporter() 		{ 			var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var xunit = new Testable_xunit { NoAutoReporters = true }; 			xunit.AvailableReporters.Add(implicitReporter);  			var reporter = xunit.GetReporter();  			Assert.IsType<DefaultRunnerReporter>(reporter); 		}  		[Fact] 		public void NoExplicitReporter_SelectsFirstEnvironmentallyEnabledReporter() 		{ 			var explicitReporter = Mocks.RunnerReporter(""switch""); 			var implicitReporter1 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var implicitReporter2 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true); 			var xunit = new Testable_xunit(); 			xunit.AvailableReporters.AddRange(new[] { explicitReporter, implicitReporter1, implicitReporter2 });  			var reporter = xunit.GetReporter();  			Assert.Same(implicitReporter1, reporter); 		}  		[Fact] 		public void BadChosenReporter_NoAvailableReporters() 		{ 			var xunit = new Testable_xunit { Reporter = ""foo"" };  			var reporter = xunit.GetReporter();  			Assert.Null(reporter); 			var eventArgs = Assert.IsType<BuildErrorEventArgs>(xunit.BuildEngine.Captured(x => x.LogErrorEvent(null)).Args().Single()); 			Assert.Equal(""Reporter value 'foo' is invalid. There are no available reporters."", eventArgs.Message); 		}  		[Fact] 		public void BadChosenReporter_WithAvailableReporters() 		{ 			var xunit = new Testable_xunit { Reporter = ""foo"" }; 			xunit.AvailableReporters.AddRange(new[] { Mocks.RunnerReporter(""switch1""), Mocks.RunnerReporter(""switch2"") });  			var reporter = xunit.GetReporter();  			Assert.Null(reporter); 			var eventArgs = Assert.IsType<BuildErrorEventArgs>(xunit.BuildEngine.Captured(x => x.LogErrorEvent(null)).Args().Single()); 			Assert.Equal(""Reporter value 'foo' is invalid. Available reporters: switch1, switch2"", eventArgs.Message); 		} 	}  	public class Testable_xunit : xunit 	{ 		public readonly List<IRunnerReporter> AvailableReporters = new();  		public Testable_xunit() 			: this(0) 		{ }  		public Testable_xunit(int exitCode) 		{ 			BuildEngine = Substitute.For<IBuildEngine>(); 			Assemblies = new ITaskItem[0]; 			ExitCode = exitCode; 		}  		protected override List<IRunnerReporter> GetAvailableRunnerReporters() => 			AvailableReporters;  		public new IRunnerReporter? GetReporter() => 			base.GetReporter(); 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.tdnet\TdNetRunner.cs,"using System; using System.Linq; using System.Reflection; using System.Threading; using TestDriven.Framework;  namespace Xunit.Runner.TdNet;  public class TdNetRunner : ITestRunner { 	public virtual TdNetRunnerHelper CreateHelper( 		ITestListener testListener, 		Assembly assembly) => 			new(assembly, testListener);  	public TestRunState RunAssembly( 		ITestListener testListener, 		Assembly assembly) 	{ 		var helper = CreateHelper(testListener, assembly);  		try 		{ 			return helper.Run(); 		} 		finally 		{ 			ThreadPool.QueueUserWorkItem(async _ => await helper.DisposeAsync()); 		} 	}  	public TestRunState RunMember( 		ITestListener testListener, 		Assembly assembly, 		MemberInfo member) 	{ 		var helper = CreateHelper(testListener, assembly);  		try 		{ 			var type = member as Type; 			if (type is not null) 				return helper.RunClass(type);  			var method = member as MethodInfo; 			if (method is not null) 				return helper.RunMethod(method);  			return TestRunState.NoTests; 		} 		finally 		{ 			ThreadPool.QueueUserWorkItem(async _ => await helper.DisposeAsync()); 		} 	}  	public TestRunState RunNamespace( 		ITestListener testListener, 		Assembly assembly, 		string ns) 	{ 		var helper = CreateHelper(testListener, assembly);  		try 		{ 			var testCases = helper.Discover().Where(tc => ns is null || tc.TestClassNamespace == ns).ToList(); 			return helper.Run(testCases); 		} 		finally 		{ 			ThreadPool.QueueUserWorkItem(async _ => await helper.DisposeAsync()); 		} 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.tdnet\TdNetRunnerHelper.cs,"using System; using System.Collections.Generic; using System.Globalization; using System.IO; using System.Linq; using System.Reflection; using System.Threading.Tasks; using TestDriven.Framework; using Xunit.Internal; using Xunit.Runner.Common; using Xunit.Runner.v2; using Xunit.Sdk; using Xunit.v3;  namespace Xunit.Runner.TdNet;  public class TdNetRunnerHelper : IAsyncDisposable { 	bool disposed; 	readonly DisposalTracker disposalTracker = new(); #pragma warning disable CA2213 // This is disposed by DisposalTracker 	readonly IFrontController? frontController; #pragma warning restore CA2213 	readonly XunitProjectAssembly? projectAssembly; 	readonly ITestListener? testListener; 	readonly object testListenerLock = new();  	/// <summary> 	/// This constructor is for unit testing purposes only. 	/// </summary> 	[Obsolete(""For unit testing purposes only"")] 	protected TdNetRunnerHelper() 	{ }  	public TdNetRunnerHelper( 		Assembly assembly, 		ITestListener testListener) 	{ 		this.testListener = testListener;  		var assemblyFileName = assembly.GetLocalCodeBase(); 		var project = new XunitProject(); 		projectAssembly = new XunitProjectAssembly(project) 		{ 			Assembly = assembly, 			AssemblyFileName = assemblyFileName, 			TargetFramework = AssemblyUtility.GetTargetFramework(assemblyFileName) 		}; 		projectAssembly.Configuration.ShadowCopy = false; 		ConfigReader.Load(projectAssembly.Configuration, assemblyFileName);  		var diagnosticMessages = projectAssembly.Configuration.DiagnosticMessagesOrDefault; 		var internalDiagnosticMessages = projectAssembly.Configuration.InternalDiagnosticMessagesOrDefault; 		var assemblyDisplayName = Path.GetFileNameWithoutExtension(assemblyFileName); #pragma warning disable CA2000 // This object is disposed in the disposal tracker 		var diagnosticMessageSink = TdNetDiagnosticMessageSink.TryCreate(testListener, testListenerLock, diagnosticMessages, internalDiagnosticMessages, assemblyDisplayName); 		disposalTracker.Add(diagnosticMessageSink); #pragma warning restore CA2000  		frontController = Xunit2.ForDiscoveryAndExecution(projectAssembly, diagnosticMessageSink: diagnosticMessageSink); 		disposalTracker.Add(frontController); 	}  	public virtual IReadOnlyList<_TestCaseDiscovered> Discover() 	{ 		Guard.NotNull(() => string.Format(CultureInfo.CurrentCulture, ""Attempted to use an uninitialized {0}.frontController"", GetType().FullName), frontController); 		Guard.NotNull(() => string.Format(CultureInfo.CurrentCulture, ""Attempted to use an uninitialized {0}.projectAssembly"", GetType().FullName), projectAssembly);  		var settings = new FrontControllerFindSettings(_TestFrameworkOptions.ForDiscovery(projectAssembly.Configuration)); 		return Discover(sink => frontController.Find(sink, settings)); 	}  	IReadOnlyList<_TestCaseDiscovered> Discover(Type? type) 	{ 		Guard.NotNull(() => string.Format(CultureInfo.CurrentCulture, ""Attempted to use an uninitialized {0}.frontController"", GetType().FullName), frontController); 		Guard.NotNull(() => string.Format(CultureInfo.CurrentCulture, ""Attempted to use an uninitialized {0}.projectAssembly"", GetType().FullName), projectAssembly);  		if (type is null || type.FullName is null) 			return Array.Empty<_TestCaseDiscovered>();  		var settings = new FrontControllerFindSettings(_TestFrameworkOptions.ForDiscovery(projectAssembly.Configuration)); 		settings.Filters.IncludedClasses.Add(type.FullName);  		return Discover(sink => frontController.Find(sink, settings)); 	}  	IReadOnlyList<_TestCaseDiscovered> Discover(Action<_IMessageSink> discoveryAction) 	{ 		try 		{ 			using var sink = new TestDiscoverySink(); 			disposalTracker.Add(sink); 			discoveryAction(sink); 			sink.Finished.WaitOne(); 			return sink.TestCases.ToList(); 		} 		catch (Exception ex) 		{ 			lock (testListenerLock) 				testListener?.WriteLine(""Error during test discovery:\r\n"" + ex, Category.Error);  			return Array.Empty<_TestCaseDiscovered>(); 		} 	}  	public ValueTask DisposeAsync() 	{ 		if (disposed) 			return default;  		disposed = true;  		GC.SuppressFinalize(this);  		return disposalTracker.DisposeAsync(); 	}  	public virtual TestRunState Run( 		IReadOnlyList<_TestCaseDiscovered>? testCases = null, 		TestRunState initialRunState = TestRunState.NoTests, 		ExplicitOption? explicitOption = null) 	{ 		Guard.NotNull(() => string.Format(CultureInfo.CurrentCulture, ""Attempted to use an uninitialized {0}.testListener"", GetType().FullName), testListener); 		Guard.NotNull(() => string.Format(CultureInfo.CurrentCulture, ""Attempted to use an uninitialized {0}.frontController"", GetType().FullName), frontController); 		Guard.NotNull(() => string.Format(CultureInfo.CurrentCulture, ""Attempted to use an uninitialized {0}.projectAssembly"", GetType().FullName), projectAssembly);  		// TODO: This does not yet support fail-on-skip or reporting long-running tests. The fact that these are done via 		// delegating implementations of IExecutionSink is a design problem for this runner.  		try 		{ 			testCases ??= Discover();  			var resultSink = new ResultSink(testListener, testListenerLock, testCases.Count) { TestRunState = initialRunState }; 			disposalTracker.Add(resultSink);  			var executionOptions = _TestFrameworkOptions.ForExecution(projectAssembly.Configuration); 			if (explicitOption.HasValue) 				executionOptions.SetExplicitOption(explicitOption);  			var settings = new FrontControllerRunSettings(executionOptions, testCases.Select(tc => tc.Serialization).CastOrToReadOnlyCollection()); 			frontController.Run(resultSink, settings);  			resultSink.Finished.WaitOne();  			return resultSink.TestRunState; 		} 		catch (Exception ex) 		{ 			lock (testListenerLock) 				testListener.WriteLine(""Error during test execution:\r\n"" + ex, Category.Error);  			return TestRunState.Error; 		} 	}  	public virtual TestRunState RunClass( 		Type type, 		TestRunState initialRunState = TestRunState.NoTests) 	{ 		Guard.ArgumentNotNull(type);  		var state = Run(Discover(type), initialRunState);  		foreach (var memberInfo in type.GetMembers()) 		{ 			var childType = memberInfo as Type; 			if (childType is not null) 				state = RunClass(childType, state); 		}  		return state; 	}  	public virtual TestRunState RunMethod( 		MethodInfo method, 		TestRunState initialRunState = TestRunState.NoTests) 	{ 		Guard.ArgumentNotNull(method);  		var testCases = Discover(method.ReflectedType).Where(tc => 		{ 			if (tc.TestClassNameWithNamespace is null || tc.TestMethodName is null) 				return false;  			var typeInfo = Type.GetType(tc.TestClassNameWithNamespace); 			if (typeInfo is null) 				return false;  			var methodInfo = typeInfo.GetMethod(tc.TestMethodName, BindingFlags.Public); 			if (methodInfo is null) 				return false;  			if (methodInfo == method) 				return true;  			if (methodInfo.IsGenericMethod) 				return methodInfo.GetGenericMethodDefinition() == method;  			return false; 		}).ToList();  		return Run(testCases, initialRunState, ExplicitOption.On); 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\src\xunit.v3.runner.tdnet.tests\TdNetRunnerTests.cs,"using System; using System.Collections.Generic; using System.Reflection; using NSubstitute; using TestDriven.Framework; using Xunit; using Xunit.Runner.TdNet; using Xunit.v3;  public class TdNetRunnerTests { 	private static readonly Assembly thisAssembly = typeof(TdNetRunnerTests).Assembly;  	public class RunMember 	{ 		class TypeUnderTest 		{ 			public event Action? Event; #pragma warning disable CS0649 			public int Field; #pragma warning restore CS0649 			public int Property { get; set; } 			public void Method() { } 		}  		[Fact] 		public void WithType() 		{ 			var listener = Substitute.For<ITestListener>(); 			var runner = new TestableTdNetRunner();  			runner.RunMember(listener, thisAssembly, typeof(TypeUnderTest));  			var msg = Assert.Single(runner.Operations); 			Assert.Equal(""RunClass(type: TdNetRunnerTests+RunMember+TypeUnderTest, initialRunState: NoTests)"", msg); 		}  		[Fact] 		public void WithMethod() 		{ 			var listener = Substitute.For<ITestListener>(); 			var runner = new TestableTdNetRunner();  			runner.RunMember(listener, thisAssembly, typeof(TypeUnderTest).GetMethod(nameof(TypeUnderTest.Method))!);  			var msg = Assert.Single(runner.Operations); 			Assert.Equal(""RunMethod(method: TdNetRunnerTests+RunMember+TypeUnderTest.Method, initialRunState: NoTests)"", msg); 		}  		[Fact] 		public void WithUnsupportedMemberTypes() 		{ 			var listener = Substitute.For<ITestListener>(); 			var runner = new TestableTdNetRunner();  			runner.RunMember(listener, thisAssembly, typeof(TypeUnderTest).GetProperty(nameof(TypeUnderTest.Property))!); 			runner.RunMember(listener, thisAssembly, typeof(TypeUnderTest).GetField(nameof(TypeUnderTest.Field))!); 			runner.RunMember(listener, thisAssembly, typeof(TypeUnderTest).GetEvent(nameof(TypeUnderTest.Event))!);  			Assert.Empty(runner.Operations); 		} 	}  	public class RunNamespace 	{ 		[Fact] 		public void RunsOnlyTestMethodsInTheGivenNamespace() 		{ 			var listener = Substitute.For<ITestListener>(); 			var runner = new TestableTdNetRunner(); 			var testCaseInNamespace = TestData.TestCaseDiscovered<DummyNamespace.ClassInNamespace>(""TestMethod""); 			var testCaseOutsideOfNamespace = TestData.TestCaseDiscovered<RunNamespace>(""RunsOnlyTestMethodsInTheGivenNamespace""); 			runner.TestsToDiscover.Clear(); 			runner.TestsToDiscover.Add(testCaseInNamespace); 			runner.TestsToDiscover.Add(testCaseOutsideOfNamespace);  			runner.RunNamespace(listener, typeof(DummyNamespace.ClassInNamespace).Assembly, ""DummyNamespace"");  			Assert.Collection( 				runner.Operations, 				msg => Assert.Equal(""Discovery()"", msg), 				msg => Assert.Equal(""Run(initialRunState: NoTests)"", msg) 			);  			var item = Assert.Single(runner.TestsRun); 			Assert.Same(testCaseInNamespace, item); 		} 	}  	class TestableTdNetRunner : TdNetRunner 	{ 		public List<string> Operations = new(); 		public List<_TestCaseDiscovered> TestsRun = new(); 		public List<_TestCaseDiscovered> TestsToDiscover = new() { Substitute.For<_TestCaseDiscovered>() };  		public override TdNetRunnerHelper CreateHelper(ITestListener testListener, Assembly assembly) 		{ 			var helper = Substitute.For<TdNetRunnerHelper>();  			helper 				.Discover() 				.Returns(callInfo => 				{ 					Operations.Add(""Discovery()""); 					return TestsToDiscover; 				});  			helper 				.Run(null, TestRunState.NoTests) 				.ReturnsForAnyArgs(callInfo => 				{ 					Operations.Add($""Run(initialRunState: {callInfo[1]})""); 					TestsRun.AddRange((IEnumerable<_TestCaseDiscovered>)callInfo[0]); 					return TestRunState.NoTests; 				});  			helper 				.RunClass(null!, TestRunState.NoTests) 				.ReturnsForAnyArgs(callInfo => 				{ 					Operations.Add($""RunClass(type: {callInfo[0]}, initialRunState: {callInfo[1]})""); 					return TestRunState.NoTests; 				});  			helper 				.RunMethod(null!, TestRunState.NoTests) 				.ReturnsForAnyArgs(callInfo => 				{ 					var method = (MethodInfo)callInfo[0]; 					Operations.Add($""RunMethod(method: {method.DeclaringType!.FullName}.{method.Name}, initialRunState: {callInfo[1]})""); 					return TestRunState.NoTests; 				});  			return helper; 		} 	} }  namespace DummyNamespace { 	public class ClassInNamespace 	{ 		public void TestMethod() 		{ } 	} }"
xunit/xunit,C:\Users\shafi\source\repos\xunit\tools\builder\Program.cs,"using System.Threading.Tasks; using McMaster.Extensions.CommandLineUtils; using Xunit.BuildTools.Models;  namespace Xunit.BuildTools;  public class Program { 	public static Task<int> Main(string[] args) 		=> CommandLineApplication.ExecuteAsync<BuildContext>(args); }"
